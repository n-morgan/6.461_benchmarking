[
  {
    "category": "sorting",
    "algorithm": "insertion_sort",
    "question": "insertion_sort:\nkey: [0.354 0.027 0.089 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047],",
    "example_output_A": "[0.027 0.089 0.354 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047]",
    "example_output_B": "[0.027 0.089 0.354 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: insertion_sort\nexample_output_A: [0.027 0.089 0.354 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047]\nexample_output_B: [0.027 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958 0.047]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\n\nquestion: insertion_sort:\nkey: [0.354 0.027 0.089 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0.027 0.047 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958]"
  },
  {
    "category": "sorting",
    "algorithm": "bubble_sort",
    "question": "bubble_sort:\nkey: [0.752 0.109 0.383 0.847 0.491 0.432 0.066],",
    "example_output_A": "[0.066 0.109 0.752 0.383 0.432 0.491 0.847]",
    "example_output_B": "[0.066 0.109 0.752 0.383 0.432 0.491 0.847]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: bubble_sort\nexample_output_A: [0.066 0.109 0.752 0.383 0.432 0.491 0.847]\nexample_output_B: [0.066 0.109 0.383 0.752 0.432 0.491 0.847]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\n\nquestion: bubble_sort:\nkey: [0.752 0.109 0.383 0.847 0.491 0.432 0.066],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0.066 0.109 0.383 0.432 0.491 0.752 0.847]"
  },
  {
    "category": "sorting",
    "algorithm": "heapsort",
    "question": "heapsort:\nkey: [0.753 0.604 0.127 0.768 0.017 0.248 0.302 0.139 0.404],",
    "example_output_A": "[0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]",
    "example_output_B": "[0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: heapsort\nexample_output_A: [0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]\nexample_output_B: [0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\n\nquestion: heapsort:\nkey: [0.753 0.604 0.127 0.768 0.017 0.248 0.302 0.139 0.404],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]"
  },
  {
    "category": "sorting",
    "algorithm": "quicksort",
    "question": "quicksort:\nkey: [0.72 0.729 0.974 0.972 0.218 0.141 0.352 0.44 0.763 0.948 0.769 0.045 0.257 0.422],",
    "example_output_A": "[0.045 0.141 0.218 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]",
    "example_output_B": "[0.045 0.141 0.218 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: quicksort\nexample_output_A: [0.045 0.141 0.218 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]\nexample_output_B: [0.218 0.141 0.974 0.972 0.72 0.729 0.352 0.44 0.763 0.948 0.769 0.045 0.257 0.422]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\n\nquestion: quicksort:\nkey: [0.72 0.729 0.974 0.972 0.218 0.141 0.352 0.44 0.763 0.948 0.769 0.045 0.257 0.422],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0.045 0.141 0.218 0.257 0.352 0.422 0.44 0.72 0.729 0.763 0.769 0.948 0.972 0.974]"
  },
  {
    "category": "searching",
    "algorithm": "minimum",
    "question": "minimum:\nkey: [0.959 0.972 0.805 0.052 0.773 0.177 0.944 0.119 0.105 0.094 0.499 0.777 0.427 0.921 0.751 0.834 0.231 0.069 0.013 0.243 0.973 0.967 0.677 0.373 0.541 0.207 0.347 0.844 0.463 0.265 0.832 0.104 0.067 0.742 0.55 0.553 0.178 0.985 0.367 0.199 0.783 0.014 0.905 0.733 0.814 0.021 0.613 0.673 0.391 0.764 0.032], initial_trace: 0",
    "example_output_A": "18",
    "example_output_B": "18",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: minimum\nexample_output_A: 18\nexample_output_B: 18\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs come from:\n  question.key            # list of numbers\n  question.target         # number, only for binary_search\n  question.k              # integer 0-based, only for quicksearch\n  question.initial_trace  # tuple of two indices (a, b), inclusive\n- algo_name selects which procedure to run: binary_search, minimum_finding, quicksearch\n- We maintain and record a STATE TRACE of the main control variables per step\n- Trace format to emit: \"(x1, y1), (x2, y2), ... | (xf, yf)\"\n  Everything before \"|\" are intermediate states. The pair after \"|\" is the terminal state.\n\n-------------------------------------------------------------------------------\nDISPATCHER (conceptual)\n-------------------------------------------------------------------------------\nif algo_name == \"binary_search\":\n    run BINARY_SEARCH with:\n        key = question.key\n        target = question.target\n        (low, high) = question.initial_trace\nelif algo_name == \"minimum_finding\":\n    run MINIMUM_FINDING with:\n        key = question.key\n        (start, end) = question.initial_trace\nelif algo_name in {\u201cquickselect\"}:\n    run QUICKSEARCH with:\n        key = question.key\n        k = question.k\n        (low, high) = question.initial_trace\n\n-------------------------------------------------------------------------------\nSCHEMA 1: BINARY_SEARCH\n-------------------------------------------------------------------------------\nGoal\n  Given sorted array key and a target, narrow the interval [low, high] until the\n  search converges or finds an exact match. Record the interval after each update.\n\nInputs\n  key: sorted ascending list of numbers\n  target: number to search\n  (low, high): inclusive indices, from question.initial_trace\n\nState and Invariant\n  Maintain low and high as inclusive bounds on the candidate region.\n  Invariant: all possible indices of the answer remain within [low, high] at each step.\n\nPseudocode\n  trace = []                               # list of (low, high)\n  lo = low\n  hi = high\n  while lo <= hi:\n      mid = floor((lo + hi) / 2)\n      if key[mid] == target:\n          lo = mid\n          hi = mid\n          append (lo, hi) to trace\n          break\n      elif key[mid] < target:\n          lo = mid + 1                     # discard left half including mid\n          append (lo, hi) to trace\n      else:\n          hi = mid - 1                     # discard right half including mid\n          append (lo, hi) to trace\n\n  Final state\n    If target found, terminal state is (mid, mid).\n    If not found, loop exits with lo = insertion point and hi = lo - 1.\n    Terminal pair for output is (max(lo, 0), max(hi, -1)) or simply (lo, hi) if you prefer.\n\nOutput\n  (lo, hi)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: MINIMUM_FINDING (linear scan)\n-------------------------------------------------------------------------------\nGoal\n  Find the index of the minimum element in key within [start, end].\n  Record the active scan window as it progresses.\n\nInputs\n  key: list of numbers\n  (start, end): inclusive scan bounds, from question.initial_trace\n\nState and Invariant\n  i moves from start to end, inclusive.\n  min_idx holds the index of the smallest value seen so far within [start, i].\n  The scan window after processing position i can be viewed as (i, end).\n\nPseudocode\n  trace = []\n  i = start\n  j = end\n  min_idx = start\n  for pos in range(i, j + 1):\n      if key[pos] < key[min_idx]:\n          min_idx = pos\n      append (pos, j) to trace             # record progress of the scan\n\n  Final state\n    Terminal pair is (min_idx, min_idx).\n\nOutput\n  (min_idx, min_idx)\n\n-------------------------------------------------------------------------------\nSCHEMA 3: QUICKSEARCH (quickselect for k-th order statistic)\n-------------------------------------------------------------------------------\nGoal\n  Return the k-th smallest element (0-based) from key within the current subarray.\n  Record the active subarray bounds (lo, hi) at each narrowing step.\n\nInputs\n  key: list of numbers\n  k: integer, 0-based rank to select\n  (low, high): inclusive subarray bounds to search\n  Optional pivot rule (if needed by your dataset): \"first\", \"last\", \"median_of_three\"\n\nState and Invariant\n  Maintain lo and hi as inclusive bounds on the subarray where the k-th element lies.\n  At each step, partition around a pivot. After partition:\n    - All elements left of pivot_pos are less than the pivot value\n    - All elements right of pivot_pos are greater than or equal to the pivot value\n  Invariant: k remains within [lo, hi] and the sought element lies in that subarray.\n\nPseudocode\n  trace = []\n  lo = low\n  hi = high\n  while lo <= hi:\n      append (lo, hi) to trace\n\n      # choose pivot index p_idx using a simple rule\n      # first:  p_idx = lo\n      # last:   p_idx = hi\n      # median_of_three: p_idx = median_index_of (lo, mid, hi)\n\n      pivot_pos = PARTITION(key, lo, hi, p_idx)\n\n      if pivot_pos == k:\n          # found exact rank\n          terminal = (k, k)\n          break\n      elif pivot_pos < k:\n          lo = pivot_pos + 1           # search right side\n      else:\n          hi = pivot_pos - 1           # search left side\n\n  Final state\n    If pivot_pos == k, terminal is (k, k).\n    Otherwise terminal is the collapsed interval (lo, hi) after the loop.\n\nOutput\n\t(lo, hi)\n\nPARTITION (Lomuto-style, index-based)\n  Input: array A, bounds [lo, hi], pivot_index p\n  Steps:\n    pivot = A[p]\n    swap A[p] and A[hi]\n    store = lo\n    for t from lo to hi - 1:\n        if A[t] < pivot:\n            swap A[t] and A[store]\n            store = store + 1\n    swap A[store] and A[hi]\n    return store   # final index of pivot\n\nNotes\n  Tracing records the subarray before partitioning at each step, which matches a common CLSR style.\n  If your worked examples prefer recording after the update, shift the append accordingly.\n\n-------------------------------------------------------------------------------\nTRACE STRING CONSTRUCTION\n-------------------------------------------------------------------------------\nGiven:\n  intermediates = [(a1, b1), (a2, b2), ..., (am, bm)]\n  final_state = (af, bf)\n\nProduce:\n  if m > 0: \"(a1, b1), (a2, b2), ..., (am, bm) | (af, bf)\"\n  else:     \"| (af, bf)\"\n\n\nquestion: minimum:\nkey: [0.959 0.972 0.805 0.052 0.773 0.177 0.944 0.119 0.105 0.094 0.499 0.777 0.427 0.921 0.751 0.834 0.231 0.069 0.013 0.243 0.973 0.967 0.677 0.373 0.541 0.207 0.347 0.844 0.463 0.265 0.832 0.104 0.067 0.742 0.55 0.553 0.178 0.985 0.367 0.199 0.783 0.014 0.905 0.733 0.814 0.021 0.613 0.673 0.391 0.764 0.032], initial_trace: 0\nalgorithm_schema: None\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "18"
  },
  {
    "category": "searching",
    "algorithm": "binary_search",
    "question": "binary_search:\nkey: [0.074 0.103 0.111 0.15 0.156 0.158 0.183 0.219 0.23 0.255 0.273 0.279 0.292 0.305 0.306 0.308 0.347 0.354 0.36 0.362 0.364 0.367 0.369 0.38 0.388 0.401 0.416 0.437 0.448 0.452 0.454 0.478 0.488 0.498 0.5 0.507 0.534 0.556 0.558 0.607 0.621 0.666 0.704 0.724 0.744 0.75 0.786 0.787 0.797 0.819 0.832 0.844 0.853 0.86 0.874 0.89 0.898 0.913 0.923 0.939 0.964 0.974], target: 0.058, initial_trace: (0, 61)",
    "example_output_A": "15)",
    "example_output_B": "15)",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: binary_search\nexample_output_A: 15)\nexample_output_B: (0\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs come from:\n  question.key            # list of numbers\n  question.target         # number, only for binary_search\n  question.k              # integer 0-based, only for quicksearch\n  question.initial_trace  # tuple of two indices (a, b), inclusive\n- algo_name selects which procedure to run: binary_search, minimum_finding, quicksearch\n- We maintain and record a STATE TRACE of the main control variables per step\n- Trace format to emit: \"(x1, y1), (x2, y2), ... | (xf, yf)\"\n  Everything before \"|\" are intermediate states. The pair after \"|\" is the terminal state.\n\n-------------------------------------------------------------------------------\nDISPATCHER (conceptual)\n-------------------------------------------------------------------------------\nif algo_name == \"binary_search\":\n    run BINARY_SEARCH with:\n        key = question.key\n        target = question.target\n        (low, high) = question.initial_trace\nelif algo_name == \"minimum_finding\":\n    run MINIMUM_FINDING with:\n        key = question.key\n        (start, end) = question.initial_trace\nelif algo_name in {\u201cquickselect\"}:\n    run QUICKSEARCH with:\n        key = question.key\n        k = question.k\n        (low, high) = question.initial_trace\n\n-------------------------------------------------------------------------------\nSCHEMA 1: BINARY_SEARCH\n-------------------------------------------------------------------------------\nGoal\n  Given sorted array key and a target, narrow the interval [low, high] until the\n  search converges or finds an exact match. Record the interval after each update.\n\nInputs\n  key: sorted ascending list of numbers\n  target: number to search\n  (low, high): inclusive indices, from question.initial_trace\n\nState and Invariant\n  Maintain low and high as inclusive bounds on the candidate region.\n  Invariant: all possible indices of the answer remain within [low, high] at each step.\n\nPseudocode\n  trace = []                               # list of (low, high)\n  lo = low\n  hi = high\n  while lo <= hi:\n      mid = floor((lo + hi) / 2)\n      if key[mid] == target:\n          lo = mid\n          hi = mid\n          append (lo, hi) to trace\n          break\n      elif key[mid] < target:\n          lo = mid + 1                     # discard left half including mid\n          append (lo, hi) to trace\n      else:\n          hi = mid - 1                     # discard right half including mid\n          append (lo, hi) to trace\n\n  Final state\n    If target found, terminal state is (mid, mid).\n    If not found, loop exits with lo = insertion point and hi = lo - 1.\n    Terminal pair for output is (max(lo, 0), max(hi, -1)) or simply (lo, hi) if you prefer.\n\nOutput\n  (lo, hi)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: MINIMUM_FINDING (linear scan)\n-------------------------------------------------------------------------------\nGoal\n  Find the index of the minimum element in key within [start, end].\n  Record the active scan window as it progresses.\n\nInputs\n  key: list of numbers\n  (start, end): inclusive scan bounds, from question.initial_trace\n\nState and Invariant\n  i moves from start to end, inclusive.\n  min_idx holds the index of the smallest value seen so far within [start, i].\n  The scan window after processing position i can be viewed as (i, end).\n\nPseudocode\n  trace = []\n  i = start\n  j = end\n  min_idx = start\n  for pos in range(i, j + 1):\n      if key[pos] < key[min_idx]:\n          min_idx = pos\n      append (pos, j) to trace             # record progress of the scan\n\n  Final state\n    Terminal pair is (min_idx, min_idx).\n\nOutput\n  (min_idx, min_idx)\n\n-------------------------------------------------------------------------------\nSCHEMA 3: QUICKSEARCH (quickselect for k-th order statistic)\n-------------------------------------------------------------------------------\nGoal\n  Return the k-th smallest element (0-based) from key within the current subarray.\n  Record the active subarray bounds (lo, hi) at each narrowing step.\n\nInputs\n  key: list of numbers\n  k: integer, 0-based rank to select\n  (low, high): inclusive subarray bounds to search\n  Optional pivot rule (if needed by your dataset): \"first\", \"last\", \"median_of_three\"\n\nState and Invariant\n  Maintain lo and hi as inclusive bounds on the subarray where the k-th element lies.\n  At each step, partition around a pivot. After partition:\n    - All elements left of pivot_pos are less than the pivot value\n    - All elements right of pivot_pos are greater than or equal to the pivot value\n  Invariant: k remains within [lo, hi] and the sought element lies in that subarray.\n\nPseudocode\n  trace = []\n  lo = low\n  hi = high\n  while lo <= hi:\n      append (lo, hi) to trace\n\n      # choose pivot index p_idx using a simple rule\n      # first:  p_idx = lo\n      # last:   p_idx = hi\n      # median_of_three: p_idx = median_index_of (lo, mid, hi)\n\n      pivot_pos = PARTITION(key, lo, hi, p_idx)\n\n      if pivot_pos == k:\n          # found exact rank\n          terminal = (k, k)\n          break\n      elif pivot_pos < k:\n          lo = pivot_pos + 1           # search right side\n      else:\n          hi = pivot_pos - 1           # search left side\n\n  Final state\n    If pivot_pos == k, terminal is (k, k).\n    Otherwise terminal is the collapsed interval (lo, hi) after the loop.\n\nOutput\n\t(lo, hi)\n\nPARTITION (Lomuto-style, index-based)\n  Input: array A, bounds [lo, hi], pivot_index p\n  Steps:\n    pivot = A[p]\n    swap A[p] and A[hi]\n    store = lo\n    for t from lo to hi - 1:\n        if A[t] < pivot:\n            swap A[t] and A[store]\n            store = store + 1\n    swap A[store] and A[hi]\n    return store   # final index of pivot\n\nNotes\n  Tracing records the subarray before partitioning at each step, which matches a common CLSR style.\n  If your worked examples prefer recording after the update, shift the append accordingly.\n\n-------------------------------------------------------------------------------\nTRACE STRING CONSTRUCTION\n-------------------------------------------------------------------------------\nGiven:\n  intermediates = [(a1, b1), (a2, b2), ..., (am, bm)]\n  final_state = (af, bf)\n\nProduce:\n  if m > 0: \"(a1, b1), (a2, b2), ..., (am, bm) | (af, bf)\"\n  else:     \"| (af, bf)\"\n\n\nquestion: binary_search:\nkey: [0.074 0.103 0.111 0.15 0.156 0.158 0.183 0.219 0.23 0.255 0.273 0.279 0.292 0.305 0.306 0.308 0.347 0.354 0.36 0.362 0.364 0.367 0.369 0.38 0.388 0.401 0.416 0.437 0.448 0.452 0.454 0.478 0.488 0.498 0.5 0.507 0.534 0.556 0.558 0.607 0.621 0.666 0.704 0.724 0.744 0.75 0.786 0.787 0.797 0.819 0.832 0.844 0.853 0.86 0.874 0.89 0.898 0.913 0.923 0.939 0.964 0.974], target: 0.058, initial_trace: (0, 61)\nalgorithm_schema: None\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "(0, 0)"
  },
  {
    "category": "searching",
    "algorithm": "quickselect",
    "question": "quickselect:\nkey: [0.74 0.539 0.811 0.555 0.822 0.313 0.698 0.529 0.711 0.68 0.256 0.959 0.769 0.242 0.78 0.286 0.389 0.988 0.763 0.542 0.554 0.231 0.996 0.935 0.957 0.819 0.922 0.076 0.743 0.095 0.415 0.619 0.236 0.185], initial_trace: 33",
    "example_output_A": "2",
    "example_output_B": "2",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: quickselect\nexample_output_A: 2\nexample_output_B: 5\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs come from:\n  question.key            # list of numbers\n  question.target         # number, only for binary_search\n  question.k              # integer 0-based, only for quicksearch\n  question.initial_trace  # tuple of two indices (a, b), inclusive\n- algo_name selects which procedure to run: binary_search, minimum_finding, quicksearch\n- We maintain and record a STATE TRACE of the main control variables per step\n- Trace format to emit: \"(x1, y1), (x2, y2), ... | (xf, yf)\"\n  Everything before \"|\" are intermediate states. The pair after \"|\" is the terminal state.\n\n-------------------------------------------------------------------------------\nDISPATCHER (conceptual)\n-------------------------------------------------------------------------------\nif algo_name == \"binary_search\":\n    run BINARY_SEARCH with:\n        key = question.key\n        target = question.target\n        (low, high) = question.initial_trace\nelif algo_name == \"minimum_finding\":\n    run MINIMUM_FINDING with:\n        key = question.key\n        (start, end) = question.initial_trace\nelif algo_name in {\u201cquickselect\"}:\n    run QUICKSEARCH with:\n        key = question.key\n        k = question.k\n        (low, high) = question.initial_trace\n\n-------------------------------------------------------------------------------\nSCHEMA 1: BINARY_SEARCH\n-------------------------------------------------------------------------------\nGoal\n  Given sorted array key and a target, narrow the interval [low, high] until the\n  search converges or finds an exact match. Record the interval after each update.\n\nInputs\n  key: sorted ascending list of numbers\n  target: number to search\n  (low, high): inclusive indices, from question.initial_trace\n\nState and Invariant\n  Maintain low and high as inclusive bounds on the candidate region.\n  Invariant: all possible indices of the answer remain within [low, high] at each step.\n\nPseudocode\n  trace = []                               # list of (low, high)\n  lo = low\n  hi = high\n  while lo <= hi:\n      mid = floor((lo + hi) / 2)\n      if key[mid] == target:\n          lo = mid\n          hi = mid\n          append (lo, hi) to trace\n          break\n      elif key[mid] < target:\n          lo = mid + 1                     # discard left half including mid\n          append (lo, hi) to trace\n      else:\n          hi = mid - 1                     # discard right half including mid\n          append (lo, hi) to trace\n\n  Final state\n    If target found, terminal state is (mid, mid).\n    If not found, loop exits with lo = insertion point and hi = lo - 1.\n    Terminal pair for output is (max(lo, 0), max(hi, -1)) or simply (lo, hi) if you prefer.\n\nOutput\n  (lo, hi)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: MINIMUM_FINDING (linear scan)\n-------------------------------------------------------------------------------\nGoal\n  Find the index of the minimum element in key within [start, end].\n  Record the active scan window as it progresses.\n\nInputs\n  key: list of numbers\n  (start, end): inclusive scan bounds, from question.initial_trace\n\nState and Invariant\n  i moves from start to end, inclusive.\n  min_idx holds the index of the smallest value seen so far within [start, i].\n  The scan window after processing position i can be viewed as (i, end).\n\nPseudocode\n  trace = []\n  i = start\n  j = end\n  min_idx = start\n  for pos in range(i, j + 1):\n      if key[pos] < key[min_idx]:\n          min_idx = pos\n      append (pos, j) to trace             # record progress of the scan\n\n  Final state\n    Terminal pair is (min_idx, min_idx).\n\nOutput\n  (min_idx, min_idx)\n\n-------------------------------------------------------------------------------\nSCHEMA 3: QUICKSEARCH (quickselect for k-th order statistic)\n-------------------------------------------------------------------------------\nGoal\n  Return the k-th smallest element (0-based) from key within the current subarray.\n  Record the active subarray bounds (lo, hi) at each narrowing step.\n\nInputs\n  key: list of numbers\n  k: integer, 0-based rank to select\n  (low, high): inclusive subarray bounds to search\n  Optional pivot rule (if needed by your dataset): \"first\", \"last\", \"median_of_three\"\n\nState and Invariant\n  Maintain lo and hi as inclusive bounds on the subarray where the k-th element lies.\n  At each step, partition around a pivot. After partition:\n    - All elements left of pivot_pos are less than the pivot value\n    - All elements right of pivot_pos are greater than or equal to the pivot value\n  Invariant: k remains within [lo, hi] and the sought element lies in that subarray.\n\nPseudocode\n  trace = []\n  lo = low\n  hi = high\n  while lo <= hi:\n      append (lo, hi) to trace\n\n      # choose pivot index p_idx using a simple rule\n      # first:  p_idx = lo\n      # last:   p_idx = hi\n      # median_of_three: p_idx = median_index_of (lo, mid, hi)\n\n      pivot_pos = PARTITION(key, lo, hi, p_idx)\n\n      if pivot_pos == k:\n          # found exact rank\n          terminal = (k, k)\n          break\n      elif pivot_pos < k:\n          lo = pivot_pos + 1           # search right side\n      else:\n          hi = pivot_pos - 1           # search left side\n\n  Final state\n    If pivot_pos == k, terminal is (k, k).\n    Otherwise terminal is the collapsed interval (lo, hi) after the loop.\n\nOutput\n\t(lo, hi)\n\nPARTITION (Lomuto-style, index-based)\n  Input: array A, bounds [lo, hi], pivot_index p\n  Steps:\n    pivot = A[p]\n    swap A[p] and A[hi]\n    store = lo\n    for t from lo to hi - 1:\n        if A[t] < pivot:\n            swap A[t] and A[store]\n            store = store + 1\n    swap A[store] and A[hi]\n    return store   # final index of pivot\n\nNotes\n  Tracing records the subarray before partitioning at each step, which matches a common CLSR style.\n  If your worked examples prefer recording after the update, shift the append accordingly.\n\n-------------------------------------------------------------------------------\nTRACE STRING CONSTRUCTION\n-------------------------------------------------------------------------------\nGiven:\n  intermediates = [(a1, b1), (a2, b2), ..., (am, bm)]\n  final_state = (af, bf)\n\nProduce:\n  if m > 0: \"(a1, b1), (a2, b2), ..., (am, bm) | (af, bf)\"\n  else:     \"| (af, bf)\"\n\n\nquestion: quickselect:\nkey: [0.74 0.539 0.811 0.555 0.822 0.313 0.698 0.529 0.711 0.68 0.256 0.959 0.769 0.242 0.78 0.286 0.389 0.988 0.763 0.542 0.554 0.231 0.996 0.935 0.957 0.819 0.922 0.076 0.743 0.095 0.415 0.619 0.236 0.185], initial_trace: 33\nalgorithm_schema: None\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "9"
  },
  {
    "category": "divideAndConquer",
    "algorithm": "find_maximum_subarray_kadane",
    "question": "find_maximum_subarray_kadane:\nkey: [-0.451 -0.135 -0.848 0.81 0.231 -0.143 -0.406 0.107 -0.806 0.299 -0.695 -0.191 0.297 0.471 0.831 -0.882 -0.346 -0.998 0.189 0.074 0.909], initial_trace: (0, 0)",
    "example_output_A": "(1",
    "example_output_B": "(1",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: find_maximum_subarray_kadane\nexample_output_A: (1\nexample_output_B: 4)\n\nUse the following schema to work through your thought process:\n\nworked_example: 1. PROBLEM HEADER\n- algorithm: <algorithm_name>\n- input: <input_data>\n- goal: <brief one-sentence description>\n\n2. BASE CASE\nIf the input size is 0 or 1:\n    - Compute the answer directly with no recursion.\n    - Return the direct result.\n\n3. DIVIDE\nDescribe exactly how the problem is split:\n    - mid = n // 2\n    - left_part = input[0:mid]\n    - right_part = input[mid:n]\n\n4. CONQUER\nRecursively solve each subproblem:\n    - left_solution = solve(left_part)\n    - right_solution = solve(right_part)\n\n(If the algorithm requires it)\n    - cross_solution = compute_cross(input, mid)\n\n5. COMBINE\nBased on the algorithm rules, combine:\n    - choose among {left_solution, right_solution, cross_solution}\nor\n    - merge the sub-results into the final result\n\nClearly state:\n    final_result = <combined result>\n\n6. LOCAL CHECK (1-step sanity check)\nApply the divide \u2192 conquer \u2192 combine logic to a tiny example:\n    mini_input = first 2\u20133 elements of input\n    Ensure steps would produce consistent behavior.\n(No full recomputation.)\n\n7. FINAL ANSWER\nFinal Answer: <result only, no explanation>\n\n\nquestion: find_maximum_subarray_kadane:\nkey: [-0.451 -0.135 -0.848 0.81 0.231 -0.143 -0.406 0.107 -0.806 0.299 -0.695 -0.191 0.297 0.471 0.831 -0.882 -0.346 -0.998 0.189 0.074 0.909], initial_trace: (0, 0)\nalgorithm_schema: 1. PROBLEM HEADER\n- algorithm: Maximum Subarray (Kadane's Algorithm)\n- input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n- goal: Find the maximum-sum contiguous subarray and return its sum.\n\n2. BASE CASE\nIf the array has size 0:\n    return 0\nIf the array has size 1:\n    return the single element\n\n3. INITIALIZE (Kadane-specific)\ncurrent_sum = input[0]\nbest_sum = input[0]\n\n4. ITERATE\nFor i from 1 to n-1:\n    current_sum = max(input[i], current_sum + input[i])\n    best_sum = max(best_sum, current_sum)\n\n5. FINAL RESULT\nfinal_result = best_sum\n\n6. LOCAL CHECK (tiny verification)\nmini_input = [-2, 1]\ncurrent_sum sequence:\n    start: -2\n    at 1: max(1, -2+1 = -1) = 1\nbest_sum becomes 1\nThis matches expected behavior.\n\n7. FINAL ANSWER\nFinal Answer: 6\n\n<answer>6</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "(12, 14)"
  },
  {
    "category": "greedy",
    "algorithm": "activity_selector",
    "question": "activity_selector:\ns: [0.244 0.367 0.241 0.504 0.719 0.334 0.145 0.307 0.542 0.057 0.323 0.042 0.322 0.332 0.462 0.795 0.03 0.375 0.116 0.205 0.677 0.497 0.613 0.018 0.569 0.097 0.301], f: [0.948 0.518 0.734 0.675 0.763 0.901 0.567 0.925 0.831 0.916 0.842 0.685 0.613 0.901 0.875 0.842 0.13 0.657 0.18 0.838 0.677 0.958 0.756 0.407 0.826 0.726 0.85],",
    "example_output_A": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]",
    "example_output_B": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: activity_selector\nexample_output_A: [0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]\nexample_output_B: [0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0]\n\nUse the following schema to work through your thought process:\n\nworked_example: Input\nalgorithm: <algorithm_name>                 \ngoal: <maximize_or_minimize>                \nitems: [                                     \n  { <feature1>: ..., <feature2>: ..., ... },\n  ...\n]\nexample_output: [...]                        \n\nStep 1: Initialize Variables\nn = number_of(items)\nselected = []\nstate = {}                                    \n\n# Define any problem-specific initial state\n# Examples:\n# state[\"last_finish\"] = -inf\n# state[\"remaining_capacity\"] = C\n# state[\"remaining_amount\"] = amount\n\nStep 2: Define Greedy Criterion\n# Step 2a: scoring rule\ndefine greedy_key(item):\n    return <feature used to rank items>\n\n# Step 2b: sort\nitems_sorted = sort(items, by=greedy_key)\n\n# Optional one-sentence rationale.\n\nStep 3: Define Feasibility Condition\ndefine feasible(item, state):\n    return <boolean feasibility condition>\n\n# Examples:\n# item.start >= state[\"last_finish\"]\n# item.value <= state[\"remaining_amount\"]\n\nStep 4: Iterate Through Items\nfor item in items_sorted:\n    if feasible(item, state):\n        selected.append(item)\n        update state using item\n        # e.g., state[\"last_finish\"] = item.finish\n\nStep 5: Optional Verification\n# Use a tiny example (\u22643 items) to verify\n# the greedy rule and feasibility logic.\n\nStep 6: Return Final Output\ntotal_value = compute_value(selected)\nreturn {\n  \"selected\": selected,\n  \"total_value\": total_value,\n  \"state\": state\n}\n\n\nquestion: activity_selector:\ns: [0.244 0.367 0.241 0.504 0.719 0.334 0.145 0.307 0.542 0.057 0.323 0.042 0.322 0.332 0.462 0.795 0.03 0.375 0.116 0.205 0.677 0.497 0.613 0.018 0.569 0.097 0.301], f: [0.948 0.518 0.734 0.675 0.763 0.901 0.567 0.925 0.831 0.916 0.842 0.685 0.613 0.901 0.875 0.842 0.13 0.657 0.18 0.838 0.677 0.958 0.756 0.407 0.826 0.726 0.85],\nalgorithm_schema: Input\nalgorithm: \"Activity Selection\"\ngoal: \"maximize number of non-overlapping activities\"\nitems: [\n  {start: 1, finish: 2},\n  {start: 3, finish: 4},\n  {start: 0, finish: 6},\n  {start: 5, finish: 7},\n  {start: 8, finish: 9},\n  {start: 5, finish: 9}\n]\nexample_output: [0, 1, 3, 4]\n\nStep 1: Initialize Variables\nn = 6\nselected = []\nstate = {\"last_finish\": -inf}\n\nStep 2: Define Greedy Criterion\ndefine greedy_key(item):\n    return item.finish\n\nitems_sorted =\n[\n  {start:1,finish:2},   # index 0\n  {start:3,finish:4},   # index 1\n  {start:5,finish:7},   # index 3\n  {start:0,finish:6},   # index 2\n  {start:8,finish:9},   # index 4\n  {start:5,finish:9}    # index 5\n]\n\n# Rationale: earliest finishing activity leaves maximum room.\n\nStep 3: Define Feasibility\ndefine feasible(item, state):\n    return item.start >= state[\"last_finish\"]\n\nStep 4: Iterate\nitem 0 \u2192 start=1 >= -inf \u2192 select \u2192 last_finish=2\nitem 1 \u2192 start=3 >= 2   \u2192 select \u2192 last_finish=4\nitem 3 \u2192 start=5 >= 4   \u2192 select \u2192 last_finish=7\nitem 2 \u2192 start=0 < 7    \u2192 skip\nitem 4 \u2192 start=8 >= 7   \u2192 select \u2192 last_finish=9\nitem 5 \u2192 start=5 < 9    \u2192 skip\n\nStep 6: Final Output\n{\n  \"selected\": [0, 1, 3, 4],\n  \"total_value\": null,\n  \"state\": {\"last_finish\": 9}\n}\n\n<answer>[0 1 0 1 1 0]</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]"
  },
  {
    "category": "greedy",
    "algorithm": "task_scheduling",
    "question": "task_scheduling:\nd: [15 15 14 28 11 30 12 1 25 15 21 23 12 25 16 1 16 12 27 26 34 20 14 4 22 18 32 20 28 1 28 23 12 8], w: [0.386 0.499 0.472 0.885 0.902 0.989 0.521 0.281 0.12 0.018 0.093 0.938 0.225 0.205 0.579 0.825 0.809 0.176 0.629 0.753 0.094 0.709 0.348 0.61 0.091 0.425 0.382 0.684 0.284 0.761 0.434 0.54 0.928 0.019],",
    "example_output_A": "[0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]",
    "example_output_B": "[0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: task_scheduling\nexample_output_A: [0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]\nexample_output_B: [0 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n\nUse the following schema to work through your thought process:\n\nworked_example: Input\nalgorithm: <algorithm_name>                 \ngoal: <maximize_or_minimize>                \nitems: [                                     \n  { <feature1>: ..., <feature2>: ..., ... },\n  ...\n]\nexample_output: [...]                        \n\nStep 1: Initialize Variables\nn = number_of(items)\nselected = []\nstate = {}                                    \n\n# Define any problem-specific initial state\n# Examples:\n# state[\"last_finish\"] = -inf\n# state[\"remaining_capacity\"] = C\n# state[\"remaining_amount\"] = amount\n\nStep 2: Define Greedy Criterion\n# Step 2a: scoring rule\ndefine greedy_key(item):\n    return <feature used to rank items>\n\n# Step 2b: sort\nitems_sorted = sort(items, by=greedy_key)\n\n# Optional one-sentence rationale.\n\nStep 3: Define Feasibility Condition\ndefine feasible(item, state):\n    return <boolean feasibility condition>\n\n# Examples:\n# item.start >= state[\"last_finish\"]\n# item.value <= state[\"remaining_amount\"]\n\nStep 4: Iterate Through Items\nfor item in items_sorted:\n    if feasible(item, state):\n        selected.append(item)\n        update state using item\n        # e.g., state[\"last_finish\"] = item.finish\n\nStep 5: Optional Verification\n# Use a tiny example (\u22643 items) to verify\n# the greedy rule and feasibility logic.\n\nStep 6: Return Final Output\ntotal_value = compute_value(selected)\nreturn {\n  \"selected\": selected,\n  \"total_value\": total_value,\n  \"state\": state\n}\n\n\nquestion: task_scheduling:\nd: [15 15 14 28 11 30 12 1 25 15 21 23 12 25 16 1 16 12 27 26 34 20 14 4 22 18 32 20 28 1 28 23 12 8], w: [0.386 0.499 0.472 0.885 0.902 0.989 0.521 0.281 0.12 0.018 0.093 0.938 0.225 0.205 0.579 0.825 0.809 0.176 0.629 0.753 0.094 0.709 0.348 0.61 0.091 0.425 0.382 0.684 0.284 0.761 0.434 0.54 0.928 0.019],\nalgorithm_schema: Input\nalgorithm: \"Activity Selection\"\ngoal: \"maximize number of non-overlapping activities\"\nitems: [\n  {start: 1, finish: 2},\n  {start: 3, finish: 4},\n  {start: 0, finish: 6},\n  {start: 5, finish: 7},\n  {start: 8, finish: 9},\n  {start: 5, finish: 9}\n]\nexample_output: [0, 1, 3, 4]\n\nStep 1: Initialize Variables\nn = 6\nselected = []\nstate = {\"last_finish\": -inf}\n\nStep 2: Define Greedy Criterion\ndefine greedy_key(item):\n    return item.finish\n\nitems_sorted =\n[\n  {start:1,finish:2},   # index 0\n  {start:3,finish:4},   # index 1\n  {start:5,finish:7},   # index 3\n  {start:0,finish:6},   # index 2\n  {start:8,finish:9},   # index 4\n  {start:5,finish:9}    # index 5\n]\n\n# Rationale: earliest finishing activity leaves maximum room.\n\nStep 3: Define Feasibility\ndefine feasible(item, state):\n    return item.start >= state[\"last_finish\"]\n\nStep 4: Iterate\nitem 0 \u2192 start=1 >= -inf \u2192 select \u2192 last_finish=2\nitem 1 \u2192 start=3 >= 2   \u2192 select \u2192 last_finish=4\nitem 3 \u2192 start=5 >= 4   \u2192 select \u2192 last_finish=7\nitem 2 \u2192 start=0 < 7    \u2192 skip\nitem 4 \u2192 start=8 >= 7   \u2192 select \u2192 last_finish=9\nitem 5 \u2192 start=5 < 9    \u2192 skip\n\nStep 6: Final Output\n{\n  \"selected\": [0, 1, 3, 4],\n  \"total_value\": null,\n  \"state\": {\"last_finish\": 9}\n}\n\n<answer>[0 1 0 1 1 0]</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 0 1 1 1 0]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "matrix_chain_order",
    "question": "matrix_chain_order:\np: [0.872 0.642 0.651 0.311 0.48 0.57 0.5 0.49 0.872 0.458 0.951 0.715 0.387],",
    "example_output_A": "[0 0 0 0 0 0 0 0 0 8 9 9 9]",
    "example_output_B": "[0 0 0 0 0 0 0 0 0 8 9 9 9]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: matrix_chain_order\nexample_output_A: [0 0 0 0 0 0 0 0 0 8 9 9 9]\nexample_output_B: [0 0 0 0 0 0 5 0 0 0 0 0 0]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Dynamic Programming Thought Schema ---\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Problem Name\": \"\",\n        \"Operation Type\": \"\",  # e.g., \"define subproblem\", \"compute recurrence\", \"fill table\", \"reconstruct solution\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"Any | list[Any] | dict[str, Any]\",\n            \"description\": \"Snapshot of the problem inputs.\",\n        },\n        \"Subproblem Table\": {\n            \"type\": \"list[Any] | dict[tuple, Any]\",\n            \"description\": \"Structure that stores solutions to subproblems (e.g., dp[i][j], memo[(i,j)]).\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"tuple[int, ...] | str\",\n            \"description\": \"The subproblem currently being computed or considered.\",\n        },\n        \"Base Case\": {\n            \"type\": \"l\",\n            \"description\": \"When should the subproblem should return a direct value and what value should it return.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Stopping condition signaling completion (e.g., 'all subproblems computed').\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": \"Any\",\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"Any | list[Any] | tuple\",\n            \"description\": \"Decision variables used in recurrence (e.g., split index, include/exclude).\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the computation logic and intended updates to the DP table.\",\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This block demonstrates a general dynamic programming reasoning loop\n\n# Initialize general state containers\ndp_table: dict[Any, Any] = {}\nsubproblem_order: list[Any] = []  # dynamically populated during computation\ntermination_condition = False\n\n# Generic Computation:\n# In a real scenario, subproblem_order and dependencies would be generated\n# from the problem definition dynamically (e.g., recursion unrolling, table indices, etc.\n\nstep_id = 0\n\nwhile not termination_condition:\n    # Dynamically decide next subproblem (abstract placeholder)\n    # In a real system, this would be determined from unmet dependencies or next table cell\n    current_subproblem = f\"Subproblem_{step_id}\"\n    subproblem_order.append(current_subproblem)\n\n    # Check if current subproblem qualifies as a base case\n    # (In practice, this would depend on indices or boundary conditions)\n    is_base_case = (step_id == 0)\n\n    if is_base_case:\n        dp_table[current_subproblem] = \u201c\u201d  # Base case placeholder value\n        operation_type = \"base case\"\n        reasoning = f\"Identified {current_subproblem} as a base case\n    else:\n        # Gather dependent results dynamically from dp_table\n        dependent_subproblems = list(dp_table.keys())\n        dependent_values = [dp_table[sub] for sub in dependent_subproblems]\n\n        # Apply a generic recurrence combination rule (abstract)\n        dp_table[current_subproblem] = sum(dependent_values) + recurrence_value\n        operation_type = \"compute recurrence\"\n        reasoning = (\n            f\"Computed {current_subproblem} using values from {dependent_subproblems} \u2192 {dp_table[current_subproblem]}\"\n        )\n    step_id += 1\n\n    # Termination logic: \n    If termination_conditions: \n\tbreak\n\nquestion: matrix_chain_order:\np: [0.872 0.642 0.651 0.311 0.48 0.57 0.5 0.49 0.872 0.458 0.951 0.715 0.387],\nalgorithm_schema: Question optimal_bst:\np: [0.06 0.116 0.097 0.007 0], q: [0.022 0.179 0.166 0.167 0.184], \ninitial_trace: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]\ntrace | root:\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0\n        \"Problem Name\": \"Optimal_bst\",\n        \"Operation Type\": \"Compute Recurrence\", \n        \"Explanation\": \"Computing the recurrence relationship for an initial call to solving the problem at step 0\",      },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"dictionary of lists\",\n            \"description\":  dict{\u201cp\u201d:  [0.06 0.116 0.097 0.007 0], \u201cq\u201d: [0.022 0.179 0.166 0.167 0.184], \u201cinitial_trace\u201d: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]},\n        },\n        \"Subproblem Table\": {\n            \"type\": \u201cDictionary\",\n            \"description\": \u201ce[i][j] \u2013 e is a dictionary representing the expected cost for searching tree spanning i to j\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"e[1][n]\",\n            \"description\": \"The subproblem currently being computed or considered. This is the first initial recursive call to the solution\",\n        },\n        \"Base Case Indicator\": {\n            \"type\": e[i][i-1],\n            \"description\": \u201creturn q_{i-1}\u201d\n        },\n        \"Termination Condition\": {\n            \"type\":\u201d e[1][n] returns a value\u201d,\n            \"description\": \"when e[1][n] returns a value, all subproblems computed.\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": e[i][j]=min_{r=i}^{j}\u200b(e[i][r\u22121]+e[r+1][j]+w[i][j])  where w[i][j] = sum from k=1 to i of p_k + sum from k=1 to j of q_k\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"[i,j]\",\n            \"description\": \"choose j that minimizes the expression in \u201cRecurrence Application\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"Recurrence calls on e[i][j]\",\n            \"description\": \"This is the first recurrence call for choosing indices i,j\",\n        },\n    }\n}\n\n<answer> [[0 0 1 1 2], [0 0 1 1 2], [0 0 0 2 2], [0 0 0 0 3], [0 0 0 0 0]]<\\answer>\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 1 1 3 3 3 3 3 3 3 3 3], [0 0 0 2 3 3 3 3 3 3 3 3 3], [0 0 0 0 3 3 3 3 3 3 3 3 3], [0 0 0 0 0 4 5 6 7 8 9 10 11], [0 0 0 0 0 0 5 6 7 6 9 9 5], [0 0 0 0 0 0 0 6 7 6 9 9 6], [0 0 0 0 0 0 0 0 7 7 9 9 7], [0 0 0 0 0 0 0 0 0 8 9 9 9], [0 0 0 0 0 0 0 0 0 0 9 9 9], [0 0 0 0 0 0 0 0 0 0 0 10 10], [0 0 0 0 0 0 0 0 0 0 0 0 11], [0 0 0 0 0 0 0 0 0 0 0 0 0]]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "lcs_length",
    "question": "lcs_length:\nstring: [0 0 0 0 0 0 0 1 1 1 1 1 1], key: [2 2 2 1 3 0 2 2 1 3 2 0 2],",
    "example_output_A": "[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]",
    "example_output_B": "[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: lcs_length\nexample_output_A: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]\nexample_output_B: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Dynamic Programming Thought Schema ---\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Problem Name\": \"\",\n        \"Operation Type\": \"\",  # e.g., \"define subproblem\", \"compute recurrence\", \"fill table\", \"reconstruct solution\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"Any | list[Any] | dict[str, Any]\",\n            \"description\": \"Snapshot of the problem inputs.\",\n        },\n        \"Subproblem Table\": {\n            \"type\": \"list[Any] | dict[tuple, Any]\",\n            \"description\": \"Structure that stores solutions to subproblems (e.g., dp[i][j], memo[(i,j)]).\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"tuple[int, ...] | str\",\n            \"description\": \"The subproblem currently being computed or considered.\",\n        },\n        \"Base Case\": {\n            \"type\": \"l\",\n            \"description\": \"When should the subproblem should return a direct value and what value should it return.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Stopping condition signaling completion (e.g., 'all subproblems computed').\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": \"Any\",\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"Any | list[Any] | tuple\",\n            \"description\": \"Decision variables used in recurrence (e.g., split index, include/exclude).\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the computation logic and intended updates to the DP table.\",\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This block demonstrates a general dynamic programming reasoning loop\n\n# Initialize general state containers\ndp_table: dict[Any, Any] = {}\nsubproblem_order: list[Any] = []  # dynamically populated during computation\ntermination_condition = False\n\n# Generic Computation:\n# In a real scenario, subproblem_order and dependencies would be generated\n# from the problem definition dynamically (e.g., recursion unrolling, table indices, etc.\n\nstep_id = 0\n\nwhile not termination_condition:\n    # Dynamically decide next subproblem (abstract placeholder)\n    # In a real system, this would be determined from unmet dependencies or next table cell\n    current_subproblem = f\"Subproblem_{step_id}\"\n    subproblem_order.append(current_subproblem)\n\n    # Check if current subproblem qualifies as a base case\n    # (In practice, this would depend on indices or boundary conditions)\n    is_base_case = (step_id == 0)\n\n    if is_base_case:\n        dp_table[current_subproblem] = \u201c\u201d  # Base case placeholder value\n        operation_type = \"base case\"\n        reasoning = f\"Identified {current_subproblem} as a base case\n    else:\n        # Gather dependent results dynamically from dp_table\n        dependent_subproblems = list(dp_table.keys())\n        dependent_values = [dp_table[sub] for sub in dependent_subproblems]\n\n        # Apply a generic recurrence combination rule (abstract)\n        dp_table[current_subproblem] = sum(dependent_values) + recurrence_value\n        operation_type = \"compute recurrence\"\n        reasoning = (\n            f\"Computed {current_subproblem} using values from {dependent_subproblems} \u2192 {dp_table[current_subproblem]}\"\n        )\n    step_id += 1\n\n    # Termination logic: \n    If termination_conditions: \n\tbreak\n\nquestion: lcs_length:\nstring: [0 0 0 0 0 0 0 1 1 1 1 1 1], key: [2 2 2 1 3 0 2 2 1 3 2 0 2],\nalgorithm_schema: Question optimal_bst:\np: [0.06 0.116 0.097 0.007 0], q: [0.022 0.179 0.166 0.167 0.184], \ninitial_trace: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]\ntrace | root:\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0\n        \"Problem Name\": \"Optimal_bst\",\n        \"Operation Type\": \"Compute Recurrence\", \n        \"Explanation\": \"Computing the recurrence relationship for an initial call to solving the problem at step 0\",      },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"dictionary of lists\",\n            \"description\":  dict{\u201cp\u201d:  [0.06 0.116 0.097 0.007 0], \u201cq\u201d: [0.022 0.179 0.166 0.167 0.184], \u201cinitial_trace\u201d: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]},\n        },\n        \"Subproblem Table\": {\n            \"type\": \u201cDictionary\",\n            \"description\": \u201ce[i][j] \u2013 e is a dictionary representing the expected cost for searching tree spanning i to j\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"e[1][n]\",\n            \"description\": \"The subproblem currently being computed or considered. This is the first initial recursive call to the solution\",\n        },\n        \"Base Case Indicator\": {\n            \"type\": e[i][i-1],\n            \"description\": \u201creturn q_{i-1}\u201d\n        },\n        \"Termination Condition\": {\n            \"type\":\u201d e[1][n] returns a value\u201d,\n            \"description\": \"when e[1][n] returns a value, all subproblems computed.\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": e[i][j]=min_{r=i}^{j}\u200b(e[i][r\u22121]+e[r+1][j]+w[i][j])  where w[i][j] = sum from k=1 to i of p_k + sum from k=1 to j of q_k\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"[i,j]\",\n            \"description\": \"choose j that minimizes the expression in \u201cRecurrence Application\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"Recurrence calls on e[i][j]\",\n            \"description\": \"This is the first recurrence call for choosing indices i,j\",\n        },\n    }\n}\n\n<answer> [[0 0 1 1 2], [0 0 1 1 2], [0 0 0 2 2], [0 0 0 0 3], [0 0 0 0 0]]<\\answer>\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[-1 -1 -1 -1 -1 -1 -1 0 2 2 0 2 0], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 2 0], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 1 0], [-1 -1 -1 -1 -1 -1 -1 1 0 2 1 1 1], [-1 -1 -1 -1 -1 -1 -1 1 1 0 2 2 1], [-1 -1 -1 -1 -1 -1 -1 1 1 1 1 0 2], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 1 0], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "optimal_bst",
    "question": "optimal_bst:\np: [0.035 0.076 0.085 0.011 0.06 0.065 0.031 0], q: [0.089 0.011 0.104 0.072 0.062 0.138 0.135 0.025],",
    "example_output_A": "[0 0 1 2 2 0 0 0]",
    "example_output_B": "[0 0 1 2 2 0 0 0]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: optimal_bst\nexample_output_A: [0 0 1 2 2 0 0 0]\nexample_output_B: [0 0 0 0 0 0 0 0]]\n\nUse the following schema to work through your thought process:\n\nworked_example: # --- Dynamic Programming Thought Schema ---\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Problem Name\": \"\",\n        \"Operation Type\": \"\",  # e.g., \"define subproblem\", \"compute recurrence\", \"fill table\", \"reconstruct solution\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"Any | list[Any] | dict[str, Any]\",\n            \"description\": \"Snapshot of the problem inputs.\",\n        },\n        \"Subproblem Table\": {\n            \"type\": \"list[Any] | dict[tuple, Any]\",\n            \"description\": \"Structure that stores solutions to subproblems (e.g., dp[i][j], memo[(i,j)]).\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"tuple[int, ...] | str\",\n            \"description\": \"The subproblem currently being computed or considered.\",\n        },\n        \"Base Case\": {\n            \"type\": \"l\",\n            \"description\": \"When should the subproblem should return a direct value and what value should it return.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Stopping condition signaling completion (e.g., 'all subproblems computed').\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": \"Any\",\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"Any | list[Any] | tuple\",\n            \"description\": \"Decision variables used in recurrence (e.g., split index, include/exclude).\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the computation logic and intended updates to the DP table.\",\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This block demonstrates a general dynamic programming reasoning loop\n\n# Initialize general state containers\ndp_table: dict[Any, Any] = {}\nsubproblem_order: list[Any] = []  # dynamically populated during computation\ntermination_condition = False\n\n# Generic Computation:\n# In a real scenario, subproblem_order and dependencies would be generated\n# from the problem definition dynamically (e.g., recursion unrolling, table indices, etc.\n\nstep_id = 0\n\nwhile not termination_condition:\n    # Dynamically decide next subproblem (abstract placeholder)\n    # In a real system, this would be determined from unmet dependencies or next table cell\n    current_subproblem = f\"Subproblem_{step_id}\"\n    subproblem_order.append(current_subproblem)\n\n    # Check if current subproblem qualifies as a base case\n    # (In practice, this would depend on indices or boundary conditions)\n    is_base_case = (step_id == 0)\n\n    if is_base_case:\n        dp_table[current_subproblem] = \u201c\u201d  # Base case placeholder value\n        operation_type = \"base case\"\n        reasoning = f\"Identified {current_subproblem} as a base case\n    else:\n        # Gather dependent results dynamically from dp_table\n        dependent_subproblems = list(dp_table.keys())\n        dependent_values = [dp_table[sub] for sub in dependent_subproblems]\n\n        # Apply a generic recurrence combination rule (abstract)\n        dp_table[current_subproblem] = sum(dependent_values) + recurrence_value\n        operation_type = \"compute recurrence\"\n        reasoning = (\n            f\"Computed {current_subproblem} using values from {dependent_subproblems} \u2192 {dp_table[current_subproblem]}\"\n        )\n    step_id += 1\n\n    # Termination logic: \n    If termination_conditions: \n\tbreak\n\nquestion: optimal_bst:\np: [0.035 0.076 0.085 0.011 0.06 0.065 0.031 0], q: [0.089 0.011 0.104 0.072 0.062 0.138 0.135 0.025],\nalgorithm_schema: Question optimal_bst:\np: [0.06 0.116 0.097 0.007 0], q: [0.022 0.179 0.166 0.167 0.184], \ninitial_trace: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]\ntrace | root:\n\ndynamic_programming_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0\n        \"Problem Name\": \"Optimal_bst\",\n        \"Operation Type\": \"Compute Recurrence\", \n        \"Explanation\": \"Computing the recurrence relationship for an initial call to solving the problem at step 0\",      },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"dictionary of lists\",\n            \"description\":  dict{\u201cp\u201d:  [0.06 0.116 0.097 0.007 0], \u201cq\u201d: [0.022 0.179 0.166 0.167 0.184], \u201cinitial_trace\u201d: [[0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0], [0 0 0 0 0]]},\n        },\n        \"Subproblem Table\": {\n            \"type\": \u201cDictionary\",\n            \"description\": \u201ce[i][j] \u2013 e is a dictionary representing the expected cost for searching tree spanning i to j\",\n        },\n        \"Current Subproblem Focus\": {\n            \"type\": \"e[1][n]\",\n            \"description\": \"The subproblem currently being computed or considered. This is the first initial recursive call to the solution\",\n        },\n        \"Base Case Indicator\": {\n            \"type\": e[i][i-1],\n            \"description\": \u201creturn q_{i-1}\u201d\n        },\n        \"Termination Condition\": {\n            \"type\":\u201d e[1][n] returns a value\u201d,\n            \"description\": \"when e[1][n] returns a value, all subproblems computed.\",\n        },\n    },\n\n    \"Focused Action\": {\n        \"Recurrence Application\": {\n            \"type\": e[i][j]=min_{r=i}^{j}\u200b(e[i][r\u22121]+e[r+1][j]+w[i][j])  where w[i][j] = sum from k=1 to i of p_k + sum from k=1 to j of q_k\n            \"description\": \"Result of combining previously computed subproblems according to recurrence.\",\n        },\n        \"Decision Variables / Choices\": {\n            \"type\": \"[i,j]\",\n            \"description\": \"choose j that minimizes the expression in \u201cRecurrence Application\",\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"Recurrence calls on e[i][j]\",\n            \"description\": \"This is the first recurrence call for choosing indices i,j\",\n        },\n    }\n}\n\n<answer> [[0 0 1 1 2], [0 0 1 1 2], [0 0 0 2 2], [0 0 0 0 3], [0 0 0 0 0]]<\\answer>\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[0 0 1 1 2 2 2 4], [0 0 1 2 2 2 4 4], [0 0 0 2 2 4 4 4], [0 0 0 0 3 4 4 5], [0 0 0 0 0 4 5 5], [0 0 0 0 0 0 5 5], [0 0 0 0 0 0 0 6], [0 0 0 0 0 0 0 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "dfs",
    "question": "dfs:\nA: [[0 1 0 0 0 1 1], [0 1 1 0 0 1 0], [1 0 1 0 0 1 1], [1 1 1 0 1 1 1], [1 0 1 0 0 1 1], [1 1 0 0 0 0 0], [1 1 1 0 1 0 1]],",
    "example_output_A": "[0 0 1 3 6 2 2]",
    "example_output_B": "[0 0 1 3 6 2 2]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: dfs\nexample_output_A: [0 0 1 3 6 2 2]\nexample_output_B: [0 0 1 3 6 2 2]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: dfs:\nA: [[0 1 0 0 0 1 1], [0 1 1 0 0 1 0], [1 0 1 0 0 1 1], [1 1 1 0 1 1 1], [1 0 1 0 0 1 1], [1 1 0 0 0 0 0], [1 1 1 0 1 0 1]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 0 1 3 6 2 2]"
  },
  {
    "category": "graphs",
    "algorithm": "bfs",
    "question": "bfs:\ns: 6, A: [[0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 0 0 1 0 1], [1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1 1 0 1 0 1 0 0 0 1 0 0 0], [0 1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1], [1 1 0 1 1 0 1 1 0 0 1 1 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 1 0 0 0 1 1 1 0 0 0 0], [0 1 0 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0], [0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 0 0 1 0 1 0 0 0 0 1 0 0 0], [0 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0], [1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 1 0 0], [0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1], [0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0], [0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 0], [0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 0], [0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0], [0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1], [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0], [1 1 0 1 0 1 0 1 0 0 1 1 0 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0], [0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0], [1 0 1 0 0 1 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0], [0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1], [0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0], [1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0], [1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0], [1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0], [1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0], [0 1 0 0 0 1 1 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0], [0 0 1 1 0 1 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 1 0 0 0], [0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0], [0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0], [0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 1 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0], [0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 0 0 1 0], [0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 0], [1 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0], [0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1], [0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0], [0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]],",
    "example_output_A": "[0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]",
    "example_output_B": "[0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: bfs\nexample_output_A: [0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]\nexample_output_B: [0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: bfs:\ns: 6, A: [[0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 0 0 1 0 1], [1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1 1 0 1 0 1 0 0 0 1 0 0 0], [0 1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1], [1 1 0 1 1 0 1 1 0 0 1 1 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 1 0 0 0 1 1 1 0 0 0 0], [0 1 0 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0], [0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 0 0 1 0 1 0 0 0 0 1 0 0 0], [0 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0], [1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 1 0 0], [0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1], [0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0], [0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 0], [0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 0], [0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0], [0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1], [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0], [1 1 0 1 0 1 0 1 0 0 1 1 0 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0], [0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0], [1 0 1 0 0 1 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0], [0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1], [0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0], [1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0], [1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0], [1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0], [1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0], [0 1 0 0 0 1 1 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0], [0 0 1 1 0 1 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 1 0 0 0], [0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0], [0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0], [0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 1 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0], [0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 0 0 1 0], [0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 0], [1 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0], [0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1], [0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0], [0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[5 6 25 5 1 6 6 5 24 36 6 5 5 6 10 6 5 1 25 6 15 1 10 5 6 6 1 6 10 1 10 13 6 1 6 5 6 1 1 6 5 5 1 1 1 5 5 5 6 6 10 1]"
  },
  {
    "category": "graphs",
    "algorithm": "topological_sort",
    "question": "topological_sort:\nA: [[0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 0 0 0], [1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0], [0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0], [1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 1 0], [1 1 1 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 1 1], [1 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0], [1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0], [0 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0], [1 1 1 1 0 1 1 0 0 1 1 1 1 1 0 1 1 0 0 1 1 0 0 1 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0], [0 1 1 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0], [0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 1 1 1 1 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 1 1 1 0]], initial_trace: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26], 0",
    "example_output_A": "[0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]",
    "example_output_B": "[0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: topological_sort\nexample_output_A: [0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]\nexample_output_B: [19 0 24 3 4 5 22 5 6 10 2 11 12 23 14 8 1 17 15 20 18 21 7 16 25 13 26]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: topological_sort:\nA: [[0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 0 0 0], [1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0], [0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0], [1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 1 0], [1 1 1 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 1 1], [1 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0], [1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0], [0 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0], [1 1 1 1 0 1 1 0 0 1 1 1 1 1 0 1 1 0 0 1 1 0 0 1 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0], [0 1 1 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0], [0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 1 1 1 1 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 1 1 1 0]], initial_trace: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26], 0\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[19 0 24 14 3 5 22 5 6 10 2 26 4 23 21 8 1 11 15 20 18 9 7 16 25 13 12], 17"
  },
  {
    "category": "graphs",
    "algorithm": "articulation_points",
    "question": "articulation_points:\nA: [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0], [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],",
    "example_output_A": "[0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]",
    "example_output_B": "[0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: articulation_points\nexample_output_A: [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]\nexample_output_B: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: articulation_points:\nA: [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0], [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]"
  },
  {
    "category": "graphs",
    "algorithm": "bridges",
    "question": "bridges:\nA: [[0 0 0 0 0 0 0 0], [0 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0]],",
    "example_output_A": "[-1 -1 -1 -1 -1 -1 0 -1]",
    "example_output_B": "[-1 -1 -1 -1 -1 -1 0 -1]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: bridges\nexample_output_A: [-1 -1 -1 -1 -1 -1 0 -1]\nexample_output_B: [-1 -1 -1 -1 0 -1 -1 -1]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: bridges:\nA: [[0 0 0 0 0 0 0 0], [0 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[0 -1 -1 -1 -1 -1 -1 -1], [-1 0 -1 -1 -1 -1 -1 -1], [-1 -1 0 -1 -1 -1 -1 -1], [-1 -1 -1 0 -1 -1 -1 -1], [-1 -1 -1 -1 0 -1 -1 -1], [-1 -1 -1 -1 -1 0 -1 -1], [-1 -1 -1 -1 -1 -1 0 -1], [-1 -1 -1 -1 -1 -1 -1 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "strongly_connected_components",
    "question": "strongly_connected_components:\nA: [[1 1 0 0 0 0], [1 1 0 0 1 0], [0 0 1 0 0 0], [0 0 0 0 1 0], [0 0 0 0 1 0], [0 0 0 0 0 0]],",
    "example_output_A": "[0 1 2 3 4 5]",
    "example_output_B": "[0 1 2 3 4 5]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: strongly_connected_components\nexample_output_A: [0 1 2 3 4 5]\nexample_output_B: [0 1 2 3 4 5]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: strongly_connected_components:\nA: [[1 1 0 0 0 0], [1 1 0 0 1 0], [0 0 1 0 0 0], [0 0 0 0 1 0], [0 0 0 0 1 0], [0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 0 2 3 4 5]"
  },
  {
    "category": "graphs",
    "algorithm": "mst_kruskal",
    "question": "mst_kruskal:\nA: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]],",
    "example_output_A": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]",
    "example_output_B": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: mst_kruskal\nexample_output_A: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]\nexample_output_B: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: mst_kruskal:\nA: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "mst_prim",
    "question": "mst_prim:\ns: 14, A: [[0.726 0 0 0 0 0 0.972 0.268 0 0.561 0 0 0 0.432 0 0], [0 0 0 0 0.762 0 0 0.538 0 0 0.334 0 0 0 0.151 0.925], [0 0 0 0.276 0 0.438 0 0.732 0 0 0.77 0 0 0 0 0], [0 0 0.276 0.952 0 0.185 0 0 0 0 0 0 0 0 0 0], [0 0.762 0 0 0.887 0 0 0 0 0 0 0 0.363 0 0 0], [0 0 0.438 0.185 0 0.033 0 0.295 0.345 0.079 0 0 0 0.117 0 0], [0.972 0 0 0 0 0 0 0.938 0 0.308 0 0 0 0 0.655 0], [0.268 0.538 0.732 0 0 0.295 0.938 0.599 0 0 0 0.125 0 0 0 0], [0 0 0 0 0 0.345 0 0 0.678 0 0 0 0.219 0 0.144 0.573], [0.561 0 0 0 0 0.079 0.308 0 0 0 0 0 0 0 0 0], [0 0.334 0.77 0 0 0 0 0 0 0 0 0.855 0 0.257 0 0], [0 0 0 0 0 0 0 0.125 0 0 0.855 0 0 0.591 0.057 0], [0 0 0 0 0.363 0 0 0 0.219 0 0 0 0.582 0 0 0], [0.432 0 0 0 0 0.117 0 0 0 0 0.257 0.591 0 0.893 0 0.269], [0 0.151 0 0 0 0 0.655 0 0.144 0 0 0.057 0 0 0 0.041], [0 0.925 0 0 0 0 0 0 0.573 0 0 0 0 0.269 0.041 0.185]],",
    "example_output_A": "[0 14 2 3 4 5 14 7 14 9 10 14 12 15 14 14]",
    "example_output_B": "[0 14 2 3 4 5 14 7 14 9 10 14 12 15 14 14]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: mst_prim\nexample_output_A: [0 14 2 3 4 5 14 7 14 9 10 14 12 15 14 14]\nexample_output_B: [7 14 3 5 12 13 9 11 14 5 13 14 8 15 14 14]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: mst_prim:\ns: 14, A: [[0.726 0 0 0 0 0 0.972 0.268 0 0.561 0 0 0 0.432 0 0], [0 0 0 0 0.762 0 0 0.538 0 0 0.334 0 0 0 0.151 0.925], [0 0 0 0.276 0 0.438 0 0.732 0 0 0.77 0 0 0 0 0], [0 0 0.276 0.952 0 0.185 0 0 0 0 0 0 0 0 0 0], [0 0.762 0 0 0.887 0 0 0 0 0 0 0 0.363 0 0 0], [0 0 0.438 0.185 0 0.033 0 0.295 0.345 0.079 0 0 0 0.117 0 0], [0.972 0 0 0 0 0 0 0.938 0 0.308 0 0 0 0 0.655 0], [0.268 0.538 0.732 0 0 0.295 0.938 0.599 0 0 0 0.125 0 0 0 0], [0 0 0 0 0 0.345 0 0 0.678 0 0 0 0.219 0 0.144 0.573], [0.561 0 0 0 0 0.079 0.308 0 0 0 0 0 0 0 0 0], [0 0.334 0.77 0 0 0 0 0 0 0 0 0.855 0 0.257 0 0], [0 0 0 0 0 0 0 0.125 0 0 0.855 0 0 0.591 0.057 0], [0 0 0 0 0.363 0 0 0 0.219 0 0 0 0.582 0 0 0], [0.432 0 0 0 0 0.117 0 0 0 0 0.257 0.591 0 0.893 0 0.269], [0 0.151 0 0 0 0 0.655 0 0.144 0 0 0.057 0 0 0 0.041], [0 0.925 0 0 0 0 0 0 0.573 0 0 0 0 0.269 0.041 0.185]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[7 14 3 5 12 13 9 11 14 5 13 14 8 15 14 14]"
  },
  {
    "category": "graphs",
    "algorithm": "bellman_ford",
    "question": "bellman_ford:\ns: 19, A: [[0 0 0 0 0.456 0 0 0 0 0 0 0.218 0 0 0 0 0 0.216 0 0.051 0 0 0.202 0.395 0], [0 0 0 0 0.362 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.897 0 0.312 0 0], [0 0 0.906 0 0 0 0 0 0 0.635 0 0 0 0.488 0 0 0 0 0 0 0 0 0 0.208 0], [0 0 0 0 0 0 0 0 0 0 0 0.738 0 0.277 0 0 0 0 0 0.59 0.233 0 0 0.474 0], [0.456 0.362 0 0 0 0 0 0 0.466 0 0.594 0 0.302 0 0 0 0.347 0 0 0 0 0 0 0 0], [0 0 0 0 0 0.69 0 0 0 0 0.529 0 0.308 0 0 0 0.387 0 0.574 0 0 0 0.599 0.438 0.402], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.042 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.433 0 0 0.688 0 0 0.633 0 0.17 0 0 0.184 0.338 0 0.151 0.529 0 0.143], [0 0 0 0 0.466 0 0 0 0 0 0 0 0 0 0.444 0 0 0 0 0 0 0 0 0 0.551], [0 0 0.635 0 0 0 0 0 0 0.844 0.904 0 0.075 0 0 0.344 0 0 0.125 0 0 0 0 0 0], [0 0 0 0 0.594 0.529 0 0.688 0 0.904 0.336 0 0.581 0 0 0 0.243 0 0 0.507 0 0 0 0 0], [0.218 0 0 0.738 0 0 0 0 0 0 0 0 0 0 0.643 0 0.224 0.491 0.477 0 0.039 0.518 0 0 0], [0 0 0 0 0.302 0.308 0 0 0 0.075 0.581 0 0.946 0 0.761 0 0 0 0.157 0 0 0 0 0 0], [0 0 0.488 0.277 0 0 0 0.633 0 0 0 0 0 0.166 0 0.752 0 0 0.186 0 0.254 0.472 0 0 0], [0 0 0 0 0 0 0 0 0.444 0 0 0.643 0.761 0 0.391 0 0 0 0 0.085 0.554 0 0 0 0], [0 0 0 0 0 0 0 0.17 0 0.344 0 0 0 0.752 0 0.09 0 0 0 0 0.731 0 0 0 0], [0 0 0 0 0.347 0.387 0 0 0 0 0.243 0.224 0 0 0 0 0.631 0 0 0 0.405 0 0 0 0], [0.216 0 0 0 0 0 0 0 0 0 0 0.491 0 0 0 0 0 0 0.59 0 0.617 0 0 0.149 0], [0 0 0 0 0 0.574 0.042 0.184 0 0.125 0 0.477 0.157 0.186 0 0 0 0.59 0 0 0 0 0 0 0], [0.051 0 0 0.59 0 0 0 0.338 0 0 0.507 0 0 0 0.085 0 0 0 0 0.184 0 0 0.32 0 0], [0 0.897 0 0.233 0 0 0 0 0 0 0 0.039 0 0.254 0.554 0.731 0.405 0.617 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.151 0 0 0 0.518 0 0.472 0 0 0 0 0 0 0 0.901 0 0 0], [0.202 0.312 0 0 0 0.599 0 0.529 0 0 0 0 0 0 0 0 0 0 0 0.32 0 0 0.653 0 0.411], [0.395 0 0.208 0.474 0 0.438 0 0 0 0 0 0 0 0 0 0 0 0.149 0 0 0 0 0 0 0], [0 0 0 0 0 0.402 0 0.143 0.551 0 0 0 0 0 0 0 0 0 0 0 0 0 0.411 0 0]],",
    "example_output_A": "[19 22 23 19 0 22 18 19 14 18 19 0 18 18 19 7 11 0 7 19 11 7 0 17 7]",
    "example_output_B": "[19 22 23 19 0 22 18 19 14 18 19 0 18 18 19 7 11 0 7 19 11 7 0 17 7]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: bellman_ford\nexample_output_A: [19 22 23 19 0 22 18 19 14 18 19 0 18 18 19 7 11 0 7 19 11 7 0 17 7]\nexample_output_B: [19 1 2 19 4 5 6 19 8 9 19 11 12 13 19 15 16 17 18 19 20 21 19 23 24]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: bellman_ford:\ns: 19, A: [[0 0 0 0 0.456 0 0 0 0 0 0 0.218 0 0 0 0 0 0.216 0 0.051 0 0 0.202 0.395 0], [0 0 0 0 0.362 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.897 0 0.312 0 0], [0 0 0.906 0 0 0 0 0 0 0.635 0 0 0 0.488 0 0 0 0 0 0 0 0 0 0.208 0], [0 0 0 0 0 0 0 0 0 0 0 0.738 0 0.277 0 0 0 0 0 0.59 0.233 0 0 0.474 0], [0.456 0.362 0 0 0 0 0 0 0.466 0 0.594 0 0.302 0 0 0 0.347 0 0 0 0 0 0 0 0], [0 0 0 0 0 0.69 0 0 0 0 0.529 0 0.308 0 0 0 0.387 0 0.574 0 0 0 0.599 0.438 0.402], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.042 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.433 0 0 0.688 0 0 0.633 0 0.17 0 0 0.184 0.338 0 0.151 0.529 0 0.143], [0 0 0 0 0.466 0 0 0 0 0 0 0 0 0 0.444 0 0 0 0 0 0 0 0 0 0.551], [0 0 0.635 0 0 0 0 0 0 0.844 0.904 0 0.075 0 0 0.344 0 0 0.125 0 0 0 0 0 0], [0 0 0 0 0.594 0.529 0 0.688 0 0.904 0.336 0 0.581 0 0 0 0.243 0 0 0.507 0 0 0 0 0], [0.218 0 0 0.738 0 0 0 0 0 0 0 0 0 0 0.643 0 0.224 0.491 0.477 0 0.039 0.518 0 0 0], [0 0 0 0 0.302 0.308 0 0 0 0.075 0.581 0 0.946 0 0.761 0 0 0 0.157 0 0 0 0 0 0], [0 0 0.488 0.277 0 0 0 0.633 0 0 0 0 0 0.166 0 0.752 0 0 0.186 0 0.254 0.472 0 0 0], [0 0 0 0 0 0 0 0 0.444 0 0 0.643 0.761 0 0.391 0 0 0 0 0.085 0.554 0 0 0 0], [0 0 0 0 0 0 0 0.17 0 0.344 0 0 0 0.752 0 0.09 0 0 0 0 0.731 0 0 0 0], [0 0 0 0 0.347 0.387 0 0 0 0 0.243 0.224 0 0 0 0 0.631 0 0 0 0.405 0 0 0 0], [0.216 0 0 0 0 0 0 0 0 0 0 0.491 0 0 0 0 0 0 0.59 0 0.617 0 0 0.149 0], [0 0 0 0 0 0.574 0.042 0.184 0 0.125 0 0.477 0.157 0.186 0 0 0 0.59 0 0 0 0 0 0 0], [0.051 0 0 0.59 0 0 0 0.338 0 0 0.507 0 0 0 0.085 0 0 0 0 0.184 0 0 0.32 0 0], [0 0.897 0 0.233 0 0 0 0 0 0 0 0.039 0 0.254 0.554 0.731 0.405 0.617 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.151 0 0 0 0.518 0 0.472 0 0 0 0 0 0 0 0.901 0 0 0], [0.202 0.312 0 0 0 0.599 0 0.529 0 0 0 0 0 0 0 0 0 0 0 0.32 0 0 0.653 0 0.411], [0.395 0 0.208 0.474 0 0.438 0 0 0 0 0 0 0 0 0 0 0 0.149 0 0 0 0 0 0 0], [0 0 0 0 0 0.402 0 0.143 0.551 0 0 0 0 0 0 0 0 0 0 0 0 0 0.411 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[19 22 23 20 0 22 18 19 14 18 19 0 18 20 19 7 11 0 7 19 11 7 0 17 7]"
  },
  {
    "category": "graphs",
    "algorithm": "dijkstra",
    "question": "dijkstra:\ns: 3, A: [[0.139 0 0 0 0.206 0], [0 0 0 0 0 0.219], [0 0 0 0 0 0.598], [0 0 0 0 0 0], [0.206 0 0 0 0 0], [0 0.219 0.598 0 0 0.653]],",
    "example_output_A": "[0 1 2 3 4 5]",
    "example_output_B": "[0 1 2 3 4 5]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: dijkstra\nexample_output_A: [0 1 2 3 4 5]\nexample_output_B: [0 1 2 3 4 5]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: dijkstra:\ns: 3, A: [[0.139 0 0 0 0.206 0], [0 0 0 0 0 0.219], [0 0 0 0 0 0.598], [0 0 0 0 0 0], [0.206 0 0 0 0 0], [0 0.219 0.598 0 0 0.653]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 1 2 3 4 5]"
  },
  {
    "category": "graphs",
    "algorithm": "dag_shortest_paths",
    "question": "dag_shortest_paths:\ns: 7, A: [[0 0.836 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0.502 0 0 0 0 0 0.512 0 0 0 0 0 0.925 0 0.321 0 0 0.913 0 0 0], [0.136 0 0 0 0 0 0 0 0 0 0 0 0 0.53 0 0 0 0 0 0 0.407 0 0 0.427], [0.237 0.943 0 0 0 0 0 0 0.00731 0.691 0 0 0 0.944 0 0 0.984 0.0368 0.875 0.678 0 0 0.947 0.627], [0.799 0.973 0 0.353 0 0 0 0 0.197 0.186 0 0.552 0.205 0 0 0 0 0 0 0.864 0 0 0.695 0], [0.826 0 0.607 0.736 0.497 0.238 0 0.397 0.305 0 0 0.0632 0 0.597 0 0.441 0 0.166 0 0 0.877 0 0.205 0], [0.823 0.769 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.464 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.976 0], [0.444 0 0 0 0 0 0 0 0 0 0 0 0 0.448 0 0 0 0 0 0.372 0 0 0 0.915], [0 0.664 0 0.779 0 0 0 0 0.673 0 0 0.144 0.849 0 0 0.0344 0.325 0 0 0 0.434 0 0.799 0], [0 0.622 0 0.382 0.895 0 0 0.111 0.338 0 0 0 0 0.68 0 0.351 0 0 0.561 0 0 0 0 0], [0 0.562 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0636 0 0 0 0 0 0.811], [0 0.144 0 0 0 0 0 0 0.583 0 0 0 0 0 0 0 0 0 0.853 0 0 0 0 0], [0 0 0.115 0.79 0 0 0 0.628 0.784 0.0645 0.783 0.00649 0 0.244 0 0.151 0.928 0.741 0.188 0 0.855 0 0 0], [0.617 0.549 0 0 0 0 0 0.268 0.193 0.116 0 0 0 0 0 0 0.901 0 0 0 0 0 0 0], [0 0.807 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0398 0.814], [0 0.114 0 0 0 0 0 0.698 0 0 0 0 0 0 0 0 0 0 0 0.0662 0 0 0.721 0.277], [0.911 0.823 0 0 0 0 0 0.598 0 0 0 0 0 0 0 0 0 0 0 0.281 0.207 0 0.0694 0.622], [0.221 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.405 0], [0 0.448 0 0 0 0 0 0.605 0.334 0 0 0 0 0 0 0 0 0 0 0.979 0 0 0 0.689], [0 0.538 0 0.115 0.238 0 0 0.927 0.748 0.205 0 0.404 0 0.101 0 0.58 0 0 0.218 0.132 0.356 0 0.0234 0], [0.23 0.0832 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0.719 0 0 0 0 0 0 0.721 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],",
    "example_output_A": "[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]",
    "example_output_B": "[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: dag_shortest_paths\nexample_output_A: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\nexample_output_B: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: dag_shortest_paths:\ns: 7, A: [[0 0.836 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0.502 0 0 0 0 0 0.512 0 0 0 0 0 0.925 0 0.321 0 0 0.913 0 0 0], [0.136 0 0 0 0 0 0 0 0 0 0 0 0 0.53 0 0 0 0 0 0 0.407 0 0 0.427], [0.237 0.943 0 0 0 0 0 0 0.00731 0.691 0 0 0 0.944 0 0 0.984 0.0368 0.875 0.678 0 0 0.947 0.627], [0.799 0.973 0 0.353 0 0 0 0 0.197 0.186 0 0.552 0.205 0 0 0 0 0 0 0.864 0 0 0.695 0], [0.826 0 0.607 0.736 0.497 0.238 0 0.397 0.305 0 0 0.0632 0 0.597 0 0.441 0 0.166 0 0 0.877 0 0.205 0], [0.823 0.769 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.464 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.976 0], [0.444 0 0 0 0 0 0 0 0 0 0 0 0 0.448 0 0 0 0 0 0.372 0 0 0 0.915], [0 0.664 0 0.779 0 0 0 0 0.673 0 0 0.144 0.849 0 0 0.0344 0.325 0 0 0 0.434 0 0.799 0], [0 0.622 0 0.382 0.895 0 0 0.111 0.338 0 0 0 0 0.68 0 0.351 0 0 0.561 0 0 0 0 0], [0 0.562 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0636 0 0 0 0 0 0.811], [0 0.144 0 0 0 0 0 0 0.583 0 0 0 0 0 0 0 0 0 0.853 0 0 0 0 0], [0 0 0.115 0.79 0 0 0 0.628 0.784 0.0645 0.783 0.00649 0 0.244 0 0.151 0.928 0.741 0.188 0 0.855 0 0 0], [0.617 0.549 0 0 0 0 0 0.268 0.193 0.116 0 0 0 0 0 0 0.901 0 0 0 0 0 0 0], [0 0.807 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0398 0.814], [0 0.114 0 0 0 0 0 0.698 0 0 0 0 0 0 0 0 0 0 0 0.0662 0 0 0.721 0.277], [0.911 0.823 0 0 0 0 0 0.598 0 0 0 0 0 0 0 0 0 0 0 0.281 0.207 0 0.0694 0.622], [0.221 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.405 0], [0 0.448 0 0 0 0 0 0.605 0.334 0 0 0 0 0 0 0 0 0 0 0.979 0 0 0 0.689], [0 0.538 0 0.115 0.238 0 0 0.927 0.748 0.205 0 0.404 0 0.101 0 0.58 0 0 0.218 0.132 0.356 0 0.0234 0], [0.23 0.0832 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0.719 0 0 0 0 0 0 0.721 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[7 7 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]"
  },
  {
    "category": "graphs",
    "algorithm": "floyd_warshall",
    "question": "floyd_warshall:\nA: [[0 0.202 0.368 0 0 0 0 0], [0.202 0 0 0.817 0 0.789 0 0], [0.368 0 0 0 0 0.072 0.256 0], [0 0.817 0 0.276 0 0 0 0], [0 0 0 0 0.422 0 0 0], [0 0.789 0.072 0 0 0.072 0 0], [0 0 0.256 0 0 0 0.569 0.706], [0 0 0 0 0 0 0.706 0]],",
    "example_output_A": "[2 0 2 1 2 2 2 2]",
    "example_output_B": "[2 0 2 1 2 2 2 2]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: floyd_warshall\nexample_output_A: [2 0 2 1 2 2 2 2]\nexample_output_B: [2 0 2 1 2 2 2 2]\n\nUse the following schema to work through your thought process:\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nquestion: floyd_warshall:\nA: [[0 0.202 0.368 0 0 0 0 0], [0.202 0 0 0.817 0 0.789 0 0], [0.368 0 0 0 0 0.072 0.256 0], [0 0.817 0 0.276 0 0 0 0], [0 0 0 0 0.422 0 0 0], [0 0.789 0.072 0 0 0.072 0 0], [0 0 0.256 0 0 0 0.569 0.706], [0 0 0 0 0 0 0.706 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[[0 0 0 1 0 2 2 6], [1 1 0 1 1 2 2 6], [2 0 2 1 2 2 2 6], [1 3 0 3 3 2 2 6], [4 4 4 4 4 4 4 4], [2 0 5 1 5 5 2 6], [2 0 6 1 6 2 2 6], [2 0 6 1 7 2 7 7]]"
  },
  {
    "category": "strings",
    "algorithm": "naive_string_matcher",
    "question": "naive_string_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1], key: [1 1 3 0 0 3 2 3 2 1 0 1 3 3 0 2 2 1 3 3 0 2 2 2 3 2 0 3 1 1 2 2 1 3 3 0 2], initial_trace: 0",
    "example_output_A": "15",
    "example_output_B": "15",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: naive_string_matcher\nexample_output_A: 15\nexample_output_B: 13\n\nUse the following schema to work through your thought process:\n\nworked_example: \"\"\"-- String Matching Algorithm Schema (Supports Naive & KMP)\n\n-- Input\ninput = {\n    \"algorithm\": \"<algorithm_name>\",   # \"Naive\" or \"KMP\"\n    \"string\": [],                      # list of symbols representing the main text\n    \"pattern\": [],                     # only for Naive\n    \"key\": [],                         # prefix-function for KMP (only for KMP)\n    \"example_output\": None             # optional\n}\n\n-- Step 1: Initialize State\nstate = {}\nstate[\"first_match\"] = None            # stores the first match index\nif input[\"algorithm\"] == \"Naive\":\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"pattern\"])\nelif input[\"algorithm\"] == \"KMP\":\n    state[\"pi\"] = input[\"key\"]         # prefix-function array\n    state[\"current_index\"] = 0         # current index in string\n    state[\"pattern_index\"] = 0         # current index in pattern (implicit from key)\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"key\"])\n\n-- Step 2: Preprocess pattern (Naive does not need; KMP key is provided)\n# For Naive: no preprocessing\n# For KMP: key is already provided\n\n-- Step 3: Search / Iterate through string\nif input[\"algorithm\"] == \"Naive\":\n    for s in range(state[\"string_length\"] - state[\"pattern_length\"] + 1):\n        match = True\n        for i in range(state[\"pattern_length\"]):\n            if input[\"string\"][s + i] != input[\"pattern\"][i]:\n                match = False\n                break\n        if match:\n            state[\"first_match\"] = s\n            break\nelif input[\"algorithm\"] == \"KMP\":\n    for state[\"current_index\"] in range(state[\"string_length\"]):\n        while state[\"pattern_index\"] > 0 and input[\"string\"][state[\"current_index\"]] != input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] = state[\"pi\"][state[\"pattern_index\"] - 1]\n        if input[\"string\"][state[\"current_index\"]] == input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] += 1\n        if state[\"pattern_index\"] == state[\"pattern_length\"]:\n            state[\"first_match\"] = state[\"current_index\"] - state[\"pattern_length\"] + 1\n            break\n\n-- Step 4: Return final output\noutput = state[\"first_match\"]    # first match index\n\nreturn output\n\"\"\"\n\n\n\nquestion: naive_string_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1], key: [1 1 3 0 0 3 2 3 2 1 0 1 3 3 0 2 2 1 3 3 0 2 2 2 3 2 0 3 1 1 2 2 1 3 3 0 2], initial_trace: 0\nalgorithm_schema: \n\n\n\"\"\"-- String Matching Algorithm Schema (Supports Naive & KMP)\n\n-- Input\ninput = {\n    \"algorithm\": \"<algorithm_name>\",   # \"Naive\" or \"KMP\"\n    \"string\": [],                      # list of symbols representing the main text\n    \"pattern\": [],                     # only for Naive\n    \"key\": [],                         # prefix-function for KMP (only for KMP)\n    \"example_output\": None             # optional\n}\n\n-- Step 1: Initialize State\nstate = {}\nstate[\"first_match\"] = None            # stores the first match index\nif input[\"algorithm\"] == \"Naive\":\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"pattern\"])\nelif input[\"algorithm\"] == \"KMP\":\n    state[\"pi\"] = input[\"key\"]         # prefix-function array\n    state[\"current_index\"] = 0         # current index in string\n    state[\"pattern_index\"] = 0         # current index in pattern (implicit from key)\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"key\"])\n\n-- Step 2: Preprocess pattern (Naive does not need; KMP key is provided)\n# For Naive: no preprocessing\n# For KMP: key is already provided\n\n-- Step 3: Search / Iterate through string\nif input[\"algorithm\"] == \"Naive\":\n    for s in range(state[\"string_length\"] - state[\"pattern_length\"] + 1):\n        match = True\n        for i in range(state[\"pattern_length\"]):\n            if input[\"string\"][s + i] != input[\"pattern\"][i]:\n                match = False\n                break\n        if match:\n            state[\"first_match\"] = s\n            break\nelif input[\"algorithm\"] == \"KMP\":\n    for state[\"current_index\"] in range(state[\"string_length\"]):\n        while state[\"pattern_index\"] > 0 and input[\"string\"][state[\"current_index\"]] != input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] = state[\"pi\"][state[\"pattern_index\"] - 1]\n        if input[\"string\"][state[\"current_index\"]] == input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] += 1\n        if state[\"pattern_index\"] == state[\"pattern_length\"]:\n            state[\"first_match\"] = state[\"current_index\"] - state[\"pattern_length\"] + 1\n            break\n\n-- Step 4: Return final output\noutput = state[\"first_match\"]    # first match index\n\nreturn output\n\"\"\"\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "15"
  },
  {
    "category": "strings",
    "algorithm": "kmp_matcher",
    "question": "kmp_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1], key: [0 1 0 0 2 0 3 0 1 3 3 3 1 1 1 2 1 1 1 2 2 2 1 2 2 3 0 1 1 3 1 0 1 0 1 3 3 3 1 1 1], initial_trace: 0",
    "example_output_A": "0",
    "example_output_B": "0",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: kmp_matcher\nexample_output_A: 0\nexample_output_B: 0\n\nUse the following schema to work through your thought process:\n\nworked_example: \"\"\"-- String Matching Algorithm Schema (Supports Naive & KMP)\n\n-- Input\ninput = {\n    \"algorithm\": \"<algorithm_name>\",   # \"Naive\" or \"KMP\"\n    \"string\": [],                      # list of symbols representing the main text\n    \"pattern\": [],                     # only for Naive\n    \"key\": [],                         # prefix-function for KMP (only for KMP)\n    \"example_output\": None             # optional\n}\n\n-- Step 1: Initialize State\nstate = {}\nstate[\"first_match\"] = None            # stores the first match index\nif input[\"algorithm\"] == \"Naive\":\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"pattern\"])\nelif input[\"algorithm\"] == \"KMP\":\n    state[\"pi\"] = input[\"key\"]         # prefix-function array\n    state[\"current_index\"] = 0         # current index in string\n    state[\"pattern_index\"] = 0         # current index in pattern (implicit from key)\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"key\"])\n\n-- Step 2: Preprocess pattern (Naive does not need; KMP key is provided)\n# For Naive: no preprocessing\n# For KMP: key is already provided\n\n-- Step 3: Search / Iterate through string\nif input[\"algorithm\"] == \"Naive\":\n    for s in range(state[\"string_length\"] - state[\"pattern_length\"] + 1):\n        match = True\n        for i in range(state[\"pattern_length\"]):\n            if input[\"string\"][s + i] != input[\"pattern\"][i]:\n                match = False\n                break\n        if match:\n            state[\"first_match\"] = s\n            break\nelif input[\"algorithm\"] == \"KMP\":\n    for state[\"current_index\"] in range(state[\"string_length\"]):\n        while state[\"pattern_index\"] > 0 and input[\"string\"][state[\"current_index\"]] != input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] = state[\"pi\"][state[\"pattern_index\"] - 1]\n        if input[\"string\"][state[\"current_index\"]] == input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] += 1\n        if state[\"pattern_index\"] == state[\"pattern_length\"]:\n            state[\"first_match\"] = state[\"current_index\"] - state[\"pattern_length\"] + 1\n            break\n\n-- Step 4: Return final output\noutput = state[\"first_match\"]    # first match index\n\nreturn output\n\"\"\"\n\n\n\nquestion: kmp_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1], key: [0 1 0 0 2 0 3 0 1 3 3 3 1 1 1 2 1 1 1 2 2 2 1 2 2 3 0 1 1 3 1 0 1 0 1 3 3 3 1 1 1], initial_trace: 0\nalgorithm_schema: \n\n\n\"\"\"-- String Matching Algorithm Schema (Supports Naive & KMP)\n\n-- Input\ninput = {\n    \"algorithm\": \"<algorithm_name>\",   # \"Naive\" or \"KMP\"\n    \"string\": [],                      # list of symbols representing the main text\n    \"pattern\": [],                     # only for Naive\n    \"key\": [],                         # prefix-function for KMP (only for KMP)\n    \"example_output\": None             # optional\n}\n\n-- Step 1: Initialize State\nstate = {}\nstate[\"first_match\"] = None            # stores the first match index\nif input[\"algorithm\"] == \"Naive\":\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"pattern\"])\nelif input[\"algorithm\"] == \"KMP\":\n    state[\"pi\"] = input[\"key\"]         # prefix-function array\n    state[\"current_index\"] = 0         # current index in string\n    state[\"pattern_index\"] = 0         # current index in pattern (implicit from key)\n    state[\"string_length\"] = len(input[\"string\"])\n    state[\"pattern_length\"] = len(input[\"key\"])\n\n-- Step 2: Preprocess pattern (Naive does not need; KMP key is provided)\n# For Naive: no preprocessing\n# For KMP: key is already provided\n\n-- Step 3: Search / Iterate through string\nif input[\"algorithm\"] == \"Naive\":\n    for s in range(state[\"string_length\"] - state[\"pattern_length\"] + 1):\n        match = True\n        for i in range(state[\"pattern_length\"]):\n            if input[\"string\"][s + i] != input[\"pattern\"][i]:\n                match = False\n                break\n        if match:\n            state[\"first_match\"] = s\n            break\nelif input[\"algorithm\"] == \"KMP\":\n    for state[\"current_index\"] in range(state[\"string_length\"]):\n        while state[\"pattern_index\"] > 0 and input[\"string\"][state[\"current_index\"]] != input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] = state[\"pi\"][state[\"pattern_index\"] - 1]\n        if input[\"string\"][state[\"current_index\"]] == input[\"string\"][state[\"pattern_index\"]]:\n            state[\"pattern_index\"] += 1\n        if state[\"pattern_index\"] == state[\"pattern_length\"]:\n            state[\"first_match\"] = state[\"current_index\"] - state[\"pattern_length\"] + 1\n            break\n\n-- Step 4: Return final output\noutput = state[\"first_match\"]    # first match index\n\nreturn output\n\"\"\"\n\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "7"
  },
  {
    "category": "geometry",
    "algorithm": "segments_intersect",
    "question": "segments_intersect:\nx: [0.212 0.845 0.981 0.521], y: [0.922 0.353 0.299 0.54]\nintersect:",
    "example_output_A": "1",
    "example_output_B": "1",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: segments_intersect\nexample_output_A: 1\nexample_output_B: 1\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs live under one of:\n    question.segment_intersection\n    question.graham_scan\n    question.jarvis_march\n- algo_name selects the procedure.\n- Emit a TRACE (sequence of snapshots) and then a terminal record after \" | \".\n- Indices always refer to the original input order.\n\nDISPATCHER (conceptual)\nif algo_name == \"segment_intersection\":\n    run SEGMENT_INTERSECTION with question.segment_intersection\nelif algo_name == \"graham_scan\":\n    run GRAHAM_SCAN with question.graham_scan\nelif algo_name == \"jarvis_march\":\n    run JARVIS_MARCH with question.jarvis_march\n\n-------------------------------------------------------------------------------\nSCHEMA 1: SEGMENT_INTERSECTION (numeric return 0/1)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A short trace of orientation tests and the decided case, followed by \" | \" and ('final', r),\n  where r is 1 if the closed segments intersect, else 0.\n\nInputs\n  question.segment_intersection:\n    segment_a: (p1, p2)   # p1=(x1,y1), p2=(x2,y2)\n    segment_b: (p3, p4)   # p3=(x3,y3), p4=(x4,y4)\n    eps: optional float tolerance (default 0)\n\nPrimitives\n  orientation(a,b,c):\n      s = cross(b-a, c-a) with cross((ux,uy),(vx,vy)) = ux*vy - uy*vx\n      return  1 if s > eps,  -1 if s < -eps,  0 otherwise\n  on_segment(a,b,c):  # assuming orientation(a,b,c) == 0\n      return (min(ax,bx)-eps <= cx <= max(ax,bx)+eps) and\n             (min(ay,by)-eps <= cy <= max(ay,by)+eps)\n\nPseudocode\n  trace = []\n  p1,p2 = segment_a\n  p3,p4 = segment_b\n  o1 = orientation(p1,p2,p3); o2 = orientation(p1,p2,p4)\n  o3 = orientation(p3,p4,p1); o4 = orientation(p3,p4,p2)\n  append (\"ori\",(o1,o2,o3,o4)) to trace\n\n  if (o1*o2 < 0) and (o3*o4 < 0):\n      append (\"case\",\"proper_cross\") to trace ; r = 1\n  elif (o1 == 0 and on_segment(p1,p2,p3)):\n      append (\"case\",\"p3_on_A\") to trace ; r = 1\n  elif (o2 == 0 and on_segment(p1,p2,p4)):\n      append (\"case\",\"p4_on_A\") to trace ; r = 1\n  elif (o3 == 0 and on_segment(p3,p4,p1)):\n      append (\"case\",\"p1_on_B\") to trace ; r = 1\n  elif (o4 == 0 and on_segment(p3,p4,p2)):\n      append (\"case\",\"p2_on_B\") to trace ; r = 1\n  else:\n      append (\"case\",\"disjoint\") to trace ; r = 0\n\nOutput\n  ('ori',(o1,o2,o3,o4)), ('case','...') | ('final', r)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: CONVEX_HULL \u2014 GRAHAM_SCAN (vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the stack after each step,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.graham_scan:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) = sign( (bx-ax)*(cy-ay) - (by-ay)*(cx-ax) )\n  pivot = argmin over j of (yj, then xj)\n  angle order = sort all indices except pivot by polar angle around pivot, tie by distance asc\n\nPseudocode\n  n = len(x)\n  trace_vectors = []\n  p = pivot\n  order = sorted(indices != p by angle around p, then distance)\n  S = [p]\n  # Optional: trace_vectors.append( snapshot(S) )\n\n  for q in order:\n      while len(S) >= 2 and orientation(S[-2], S[-1], q) <= 0:\n          S.pop()\n          trace_vectors.append( snapshot(S) )    # emit after each pop if needed\n      S.append(q)\n      trace_vectors.append( snapshot(S) )        # emit after push\n\n  H = snapshot(S)                                 # final in_hull vector\n\nOutput\n  H\n\n-------------------------------------------------------------------------------\nSCHEMA 3: CONVEX_HULL \u2014 JARVIS_MARCH (Gift Wrapping, vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the committed hull set after each wrapped vertex,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.jarvis_march:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) by cross-product sign\n  dist2(a,b) = (ax-bx)^2 + (ay-by)^2\n  start s = argmin over j of (xj, then yj)   # leftmost; tie by lowest y\n\nPseudocode\n  n = len(x)\n  Hset = { }\n  trace_vectors = []\n\n  s = start\n  Hset.add(s)\n  trace_vectors.append( snapshot(Hset) )\n  curr = s\n\n  while True:\n      q = any index != curr\n      for r in 0..n-1:\n          if r == curr or r == q: continue\n          turn = orientation(curr, q, r)\n          if turn < 0:\n              q = r\n          elif turn == 0 and dist2(curr, r) > dist2(curr, q):\n              q = r\n      if q == s:\n          break\n      Hset.add(q)\n      trace_vectors.append( snapshot(Hset) )\n      curr = q\n\n  H = snapshot(Hset)\n\nOutput\n H\n\n\nquestion: segments_intersect:\nx: [0.212 0.845 0.981 0.521], y: [0.922 0.353 0.299 0.54]\nintersect:\nalgorithm_schema: question: graham_scan:\n  x: [0, 2, 3, 2, 1, 0]\n  y: [0, 0, 1, 2, 1, 3]\n  initial_trace: [0, 0, 0, 0, 0, 0]\n\ntrace | in_hull:\n  [1 1 0 0 0 0],        # push idx 1  \u2192 S=[0,1]\n  [1 1 1 0 0 0],        # push idx 2  \u2192 S=[0,1,2]\n  [1 1 1 0 1 0],        # push idx 4  \u2192 S=[0,1,2,4]\n  [1 1 1 0 0 0],        # pop  idx 4  \u2192 S=[0,1,2]\n  [1 1 1 1 0 0],        # push idx 3  \u2192 S=[0,1,2,3]\n  [1 1 1 1 0 1]         # push idx 5  \u2192 S=[0,1,2,3,5]\n  | [1 1 1 1 0 1]       # in_hull = indices {0,1,2,3,5}\n\n<answer>[1 1 1 1 0 1]</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "1"
  },
  {
    "category": "geometry",
    "algorithm": "graham_scan",
    "question": "graham_scan:\nx: [-0.127 -1.07 -0.763 -0.619 -0.352 -0.969 1.78 1.26 -0.619 -0.76 0.593 -1.17 0.273 0.334 1.26], y: [-0.412 -1.4 -0.051 -0.975 1.67 1.26 0.311 0.79 0.067 -0.787 0.755 1.49 -1.83 -1.87 -0.338],",
    "example_output_A": "[0 0 0 0 1 0 1 1 0 0 0 1 0 1 0]",
    "example_output_B": "[0 0 0 0 1 0 1 1 0 0 0 1 0 1 0]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: graham_scan\nexample_output_A: [0 0 0 0 1 0 1 1 0 0 0 1 0 1 0]\nexample_output_B: [0 0 1 0 1 0 1 1 0 0 0 1 0 1 0]\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs live under one of:\n    question.segment_intersection\n    question.graham_scan\n    question.jarvis_march\n- algo_name selects the procedure.\n- Emit a TRACE (sequence of snapshots) and then a terminal record after \" | \".\n- Indices always refer to the original input order.\n\nDISPATCHER (conceptual)\nif algo_name == \"segment_intersection\":\n    run SEGMENT_INTERSECTION with question.segment_intersection\nelif algo_name == \"graham_scan\":\n    run GRAHAM_SCAN with question.graham_scan\nelif algo_name == \"jarvis_march\":\n    run JARVIS_MARCH with question.jarvis_march\n\n-------------------------------------------------------------------------------\nSCHEMA 1: SEGMENT_INTERSECTION (numeric return 0/1)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A short trace of orientation tests and the decided case, followed by \" | \" and ('final', r),\n  where r is 1 if the closed segments intersect, else 0.\n\nInputs\n  question.segment_intersection:\n    segment_a: (p1, p2)   # p1=(x1,y1), p2=(x2,y2)\n    segment_b: (p3, p4)   # p3=(x3,y3), p4=(x4,y4)\n    eps: optional float tolerance (default 0)\n\nPrimitives\n  orientation(a,b,c):\n      s = cross(b-a, c-a) with cross((ux,uy),(vx,vy)) = ux*vy - uy*vx\n      return  1 if s > eps,  -1 if s < -eps,  0 otherwise\n  on_segment(a,b,c):  # assuming orientation(a,b,c) == 0\n      return (min(ax,bx)-eps <= cx <= max(ax,bx)+eps) and\n             (min(ay,by)-eps <= cy <= max(ay,by)+eps)\n\nPseudocode\n  trace = []\n  p1,p2 = segment_a\n  p3,p4 = segment_b\n  o1 = orientation(p1,p2,p3); o2 = orientation(p1,p2,p4)\n  o3 = orientation(p3,p4,p1); o4 = orientation(p3,p4,p2)\n  append (\"ori\",(o1,o2,o3,o4)) to trace\n\n  if (o1*o2 < 0) and (o3*o4 < 0):\n      append (\"case\",\"proper_cross\") to trace ; r = 1\n  elif (o1 == 0 and on_segment(p1,p2,p3)):\n      append (\"case\",\"p3_on_A\") to trace ; r = 1\n  elif (o2 == 0 and on_segment(p1,p2,p4)):\n      append (\"case\",\"p4_on_A\") to trace ; r = 1\n  elif (o3 == 0 and on_segment(p3,p4,p1)):\n      append (\"case\",\"p1_on_B\") to trace ; r = 1\n  elif (o4 == 0 and on_segment(p3,p4,p2)):\n      append (\"case\",\"p2_on_B\") to trace ; r = 1\n  else:\n      append (\"case\",\"disjoint\") to trace ; r = 0\n\nOutput\n  ('ori',(o1,o2,o3,o4)), ('case','...') | ('final', r)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: CONVEX_HULL \u2014 GRAHAM_SCAN (vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the stack after each step,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.graham_scan:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) = sign( (bx-ax)*(cy-ay) - (by-ay)*(cx-ax) )\n  pivot = argmin over j of (yj, then xj)\n  angle order = sort all indices except pivot by polar angle around pivot, tie by distance asc\n\nPseudocode\n  n = len(x)\n  trace_vectors = []\n  p = pivot\n  order = sorted(indices != p by angle around p, then distance)\n  S = [p]\n  # Optional: trace_vectors.append( snapshot(S) )\n\n  for q in order:\n      while len(S) >= 2 and orientation(S[-2], S[-1], q) <= 0:\n          S.pop()\n          trace_vectors.append( snapshot(S) )    # emit after each pop if needed\n      S.append(q)\n      trace_vectors.append( snapshot(S) )        # emit after push\n\n  H = snapshot(S)                                 # final in_hull vector\n\nOutput\n  H\n\n-------------------------------------------------------------------------------\nSCHEMA 3: CONVEX_HULL \u2014 JARVIS_MARCH (Gift Wrapping, vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the committed hull set after each wrapped vertex,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.jarvis_march:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) by cross-product sign\n  dist2(a,b) = (ax-bx)^2 + (ay-by)^2\n  start s = argmin over j of (xj, then yj)   # leftmost; tie by lowest y\n\nPseudocode\n  n = len(x)\n  Hset = { }\n  trace_vectors = []\n\n  s = start\n  Hset.add(s)\n  trace_vectors.append( snapshot(Hset) )\n  curr = s\n\n  while True:\n      q = any index != curr\n      for r in 0..n-1:\n          if r == curr or r == q: continue\n          turn = orientation(curr, q, r)\n          if turn < 0:\n              q = r\n          elif turn == 0 and dist2(curr, r) > dist2(curr, q):\n              q = r\n      if q == s:\n          break\n      Hset.add(q)\n      trace_vectors.append( snapshot(Hset) )\n      curr = q\n\n  H = snapshot(Hset)\n\nOutput\n H\n\n\nquestion: graham_scan:\nx: [-0.127 -1.07 -0.763 -0.619 -0.352 -0.969 1.78 1.26 -0.619 -0.76 0.593 -1.17 0.273 0.334 1.26], y: [-0.412 -1.4 -0.051 -0.975 1.67 1.26 0.311 0.79 0.067 -0.787 0.755 1.49 -1.83 -1.87 -0.338],\nalgorithm_schema: question: graham_scan:\n  x: [0, 2, 3, 2, 1, 0]\n  y: [0, 0, 1, 2, 1, 3]\n  initial_trace: [0, 0, 0, 0, 0, 0]\n\ntrace | in_hull:\n  [1 1 0 0 0 0],        # push idx 1  \u2192 S=[0,1]\n  [1 1 1 0 0 0],        # push idx 2  \u2192 S=[0,1,2]\n  [1 1 1 0 1 0],        # push idx 4  \u2192 S=[0,1,2,4]\n  [1 1 1 0 0 0],        # pop  idx 4  \u2192 S=[0,1,2]\n  [1 1 1 1 0 0],        # push idx 3  \u2192 S=[0,1,2,3]\n  [1 1 1 1 0 1]         # push idx 5  \u2192 S=[0,1,2,3,5]\n  | [1 1 1 1 0 1]       # in_hull = indices {0,1,2,3,5}\n\n<answer>[1 1 1 1 0 1]</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[0 1 0 0 1 0 1 1 0 0 0 1 0 1 0]"
  },
  {
    "category": "geometry",
    "algorithm": "jarvis_march",
    "question": "jarvis_march:\nx: [0.478 -0.041 0.68 -0.984 0.993 -0.757 -1.4 -0.864 0.765], y: [-1.43 -1.26 0.483 -1.27 -1.27 -0.091 -0.505 -1.42 0.663],",
    "example_output_A": "[1 0 0 0 1 0 0 0 1]",
    "example_output_B": "[1 0 0 0 1 0 0 0 1]",
    "prompt": "\n\n\nYou are a helpful math assistant adept at solving math problems. \n\nalgorithm_name: jarvis_march\nexample_output_A: [1 0 0 0 1 0 0 0 1]\nexample_output_B: [1 0 0 0 1 1 1 0 1]\n\nUse the following schema to work through your thought process:\n\nworked_example: GENERAL CONVENTIONS\n- Inputs live under one of:\n    question.segment_intersection\n    question.graham_scan\n    question.jarvis_march\n- algo_name selects the procedure.\n- Emit a TRACE (sequence of snapshots) and then a terminal record after \" | \".\n- Indices always refer to the original input order.\n\nDISPATCHER (conceptual)\nif algo_name == \"segment_intersection\":\n    run SEGMENT_INTERSECTION with question.segment_intersection\nelif algo_name == \"graham_scan\":\n    run GRAHAM_SCAN with question.graham_scan\nelif algo_name == \"jarvis_march\":\n    run JARVIS_MARCH with question.jarvis_march\n\n-------------------------------------------------------------------------------\nSCHEMA 1: SEGMENT_INTERSECTION (numeric return 0/1)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A short trace of orientation tests and the decided case, followed by \" | \" and ('final', r),\n  where r is 1 if the closed segments intersect, else 0.\n\nInputs\n  question.segment_intersection:\n    segment_a: (p1, p2)   # p1=(x1,y1), p2=(x2,y2)\n    segment_b: (p3, p4)   # p3=(x3,y3), p4=(x4,y4)\n    eps: optional float tolerance (default 0)\n\nPrimitives\n  orientation(a,b,c):\n      s = cross(b-a, c-a) with cross((ux,uy),(vx,vy)) = ux*vy - uy*vx\n      return  1 if s > eps,  -1 if s < -eps,  0 otherwise\n  on_segment(a,b,c):  # assuming orientation(a,b,c) == 0\n      return (min(ax,bx)-eps <= cx <= max(ax,bx)+eps) and\n             (min(ay,by)-eps <= cy <= max(ay,by)+eps)\n\nPseudocode\n  trace = []\n  p1,p2 = segment_a\n  p3,p4 = segment_b\n  o1 = orientation(p1,p2,p3); o2 = orientation(p1,p2,p4)\n  o3 = orientation(p3,p4,p1); o4 = orientation(p3,p4,p2)\n  append (\"ori\",(o1,o2,o3,o4)) to trace\n\n  if (o1*o2 < 0) and (o3*o4 < 0):\n      append (\"case\",\"proper_cross\") to trace ; r = 1\n  elif (o1 == 0 and on_segment(p1,p2,p3)):\n      append (\"case\",\"p3_on_A\") to trace ; r = 1\n  elif (o2 == 0 and on_segment(p1,p2,p4)):\n      append (\"case\",\"p4_on_A\") to trace ; r = 1\n  elif (o3 == 0 and on_segment(p3,p4,p1)):\n      append (\"case\",\"p1_on_B\") to trace ; r = 1\n  elif (o4 == 0 and on_segment(p3,p4,p2)):\n      append (\"case\",\"p2_on_B\") to trace ; r = 1\n  else:\n      append (\"case\",\"disjoint\") to trace ; r = 0\n\nOutput\n  ('ori',(o1,o2,o3,o4)), ('case','...') | ('final', r)\n\n-------------------------------------------------------------------------------\nSCHEMA 2: CONVEX_HULL \u2014 GRAHAM_SCAN (vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the stack after each step,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.graham_scan:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) = sign( (bx-ax)*(cy-ay) - (by-ay)*(cx-ax) )\n  pivot = argmin over j of (yj, then xj)\n  angle order = sort all indices except pivot by polar angle around pivot, tie by distance asc\n\nPseudocode\n  n = len(x)\n  trace_vectors = []\n  p = pivot\n  order = sorted(indices != p by angle around p, then distance)\n  S = [p]\n  # Optional: trace_vectors.append( snapshot(S) )\n\n  for q in order:\n      while len(S) >= 2 and orientation(S[-2], S[-1], q) <= 0:\n          S.pop()\n          trace_vectors.append( snapshot(S) )    # emit after each pop if needed\n      S.append(q)\n      trace_vectors.append( snapshot(S) )        # emit after push\n\n  H = snapshot(S)                                 # final in_hull vector\n\nOutput\n  H\n\n-------------------------------------------------------------------------------\nSCHEMA 3: CONVEX_HULL \u2014 JARVIS_MARCH (Gift Wrapping, vector trace)\n-------------------------------------------------------------------------------\nOutput (one line)\n  A comma-separated sequence of length-n 0/1 vectors marking the committed hull set after each wrapped vertex,\n  followed by \" | \" and a final length-n 0/1 vector in_hull:\n  T1, T2, ..., Tk | H\n\nInputs\n  question.jarvis_march:\n    x: [x0, x1, ..., x_{n-1}]\n    y: [y0, y1, ..., y_{n-1}]\n    initial_trace: [0, 0, ..., 0]   # length n (placeholder)\n\nDefinitions\n  Pj = (xj, yj)\n  orientation(a,b,c) by cross-product sign\n  dist2(a,b) = (ax-bx)^2 + (ay-by)^2\n  start s = argmin over j of (xj, then yj)   # leftmost; tie by lowest y\n\nPseudocode\n  n = len(x)\n  Hset = { }\n  trace_vectors = []\n\n  s = start\n  Hset.add(s)\n  trace_vectors.append( snapshot(Hset) )\n  curr = s\n\n  while True:\n      q = any index != curr\n      for r in 0..n-1:\n          if r == curr or r == q: continue\n          turn = orientation(curr, q, r)\n          if turn < 0:\n              q = r\n          elif turn == 0 and dist2(curr, r) > dist2(curr, q):\n              q = r\n      if q == s:\n          break\n      Hset.add(q)\n      trace_vectors.append( snapshot(Hset) )\n      curr = q\n\n  H = snapshot(Hset)\n\nOutput\n H\n\n\nquestion: jarvis_march:\nx: [0.478 -0.041 0.68 -0.984 0.993 -0.757 -1.4 -0.864 0.765], y: [-1.43 -1.26 0.483 -1.27 -1.27 -0.091 -0.505 -1.42 0.663],\nalgorithm_schema: question: graham_scan:\n  x: [0, 2, 3, 2, 1, 0]\n  y: [0, 0, 1, 2, 1, 3]\n  initial_trace: [0, 0, 0, 0, 0, 0]\n\ntrace | in_hull:\n  [1 1 0 0 0 0],        # push idx 1  \u2192 S=[0,1]\n  [1 1 1 0 0 0],        # push idx 2  \u2192 S=[0,1,2]\n  [1 1 1 0 1 0],        # push idx 4  \u2192 S=[0,1,2,4]\n  [1 1 1 0 0 0],        # pop  idx 4  \u2192 S=[0,1,2]\n  [1 1 1 1 0 0],        # push idx 3  \u2192 S=[0,1,2,3]\n  [1 1 1 1 0 1]         # push idx 5  \u2192 S=[0,1,2,3,5]\n  | [1 1 1 1 0 1]       # in_hull = indices {0,1,2,3,5}\n\n<answer>[1 1 1 1 0 1]</answer>\n\n\nInstructions for final answer:\n- After completing your reasoning, output **only the final answer** in the exact form of example_output_A or example_output_B.\n- The final answer **must be enclosed exactly in <answer>...</answer>** tags.\n- Do not include any reasoning, explanation, or extra text inside the answer tags.\n- Place the `<answer>` line on a new line at the very end of your response.\n\n<answer>[your answer here]<\u0007nswer>\n",
    "answer": "[1 0 0 1 1 1 1 1 1]"
  }
]