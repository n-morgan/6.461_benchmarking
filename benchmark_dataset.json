[
  {
    "category": "sorting",
    "algorithm": "insertion_sort",
    "question": "insertion_sort:\nkey: [0.354 0.027 0.089 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047],",
    "example_output_A": "[0.027 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958 0.047]",
    "example_output_B": "[0.027 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958 0.047]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: insertion_sort\nexample_output_A: [0.027 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958 0.047]\nexample_output_B: [0.027 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958 0.047]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\nquestion: insertion_sort:\nkey: [0.354 0.027 0.089 0.483 0.628 0.144 0.356 0.774 0.778 0.958 0.047],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0.027 0.047 0.089 0.144 0.354 0.356 0.483 0.628 0.774 0.778 0.958]"
  },
  {
    "category": "sorting",
    "algorithm": "bubble_sort",
    "question": "bubble_sort:\nkey: [0.752 0.109 0.383 0.847 0.491 0.432 0.066],",
    "example_output_A": "[0.066 0.752 0.109 0.383 0.847 0.432 0.491]",
    "example_output_B": "[0.066 0.752 0.109 0.383 0.847 0.432 0.491]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: bubble_sort\nexample_output_A: [0.066 0.752 0.109 0.383 0.847 0.432 0.491]\nexample_output_B: [0.066 0.109 0.383 0.752 0.432 0.491 0.847]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\nquestion: bubble_sort:\nkey: [0.752 0.109 0.383 0.847 0.491 0.432 0.066],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0.066 0.109 0.383 0.432 0.491 0.752 0.847]"
  },
  {
    "category": "sorting",
    "algorithm": "heapsort",
    "question": "heapsort:\nkey: [0.753 0.604 0.127 0.768 0.017 0.248 0.302 0.139 0.404],",
    "example_output_A": "[0.127 0.017 0.139 0.248 0.302 0.404 0.604 0.753 0.768]",
    "example_output_B": "[0.127 0.017 0.139 0.248 0.302 0.404 0.604 0.753 0.768]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: heapsort\nexample_output_A: [0.127 0.017 0.139 0.248 0.302 0.404 0.604 0.753 0.768]\nexample_output_B: [0.139 0.127 0.017 0.248 0.302 0.404 0.604 0.753 0.768]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\nquestion: heapsort:\nkey: [0.753 0.604 0.127 0.768 0.017 0.248 0.302 0.139 0.404],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0.017 0.127 0.139 0.248 0.302 0.404 0.604 0.753 0.768]"
  },
  {
    "category": "sorting",
    "algorithm": "quicksort",
    "question": "quicksort:\nkey: [0.72 0.729 0.974 0.972 0.218 0.141 0.352 0.44 0.763 0.948 0.769 0.045 0.257 0.422],",
    "example_output_A": "[0.218 0.141 0.045 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]",
    "example_output_B": "[0.218 0.141 0.045 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: quicksort\nexample_output_A: [0.218 0.141 0.045 0.257 0.352 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]\nexample_output_B: [0.218 0.141 0.352 0.045 0.257 0.422 0.974 0.44 0.763 0.948 0.769 0.972 0.72 0.729]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: # --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": None,\n        \"Algorithm / Sorting Strategy\": \"\",  # e.g., \"Insertion\", \"Bubble\", \"Heap\", \"Quick\"\n        \"Operation Type\": \"\",  # e.g., \"compare\", \"swap\", \"insert\", \"partition\"\n        \"Explanation\": \"\",  # Natural language reasoning for this step\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\",\n            \"description\": \"Snapshot of the array or list being sorted.\",\n            # Example: arr = [5, 3, 1, 4]\n        },\n        \"Current Stage\": {\n            \"type\": \"list[Any] | dict[str, Any]\",\n            \"description\": \"Internal representation of how the input is progressing (e.g., heapified array, partitioned sublists).\",\n        },\n        \"Boundary of Sorted Region\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what section of the input is already sorted (e.g., indices [0:i]).\",\n        },\n        \"Remaining\": {\n            \"type\": \"list[int] | tuple[int, int]\",\n            \"description\": \"Track what part of the input still needs sorting.\",\n        },\n        \"Termination Condition\": {\n            \"type\": \"bool | str\",\n            \"description\": \"Boolean or textual stopping condition that signals when sorting is complete.\",\n            # Example: \"remaining is empty\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": {\n            \"type\": \"Any | int | float | str\",\n            \"description\": \"Element and index currently being compared, inserted, or swapped.\",\n            # Example: current = arr[i]\n        },\n        \"Comparison Target(s)\": {\n            \"type\": \"Any | list[Any]\",\n            \"description\": \"Element(s) or region of input that the current element is being compared or sorted against.\",\n            # Example: arr[i-1] or arr[j:]\n        },\n        \"Operation Type\": {\n            \"type\": \"str\",\n            \"description\": \"Defines what operation should be performed with the current element and comparison targets.\",\n            # Example: 'compare', 'swap', 'insert', 'partition'\n        },\n        \"Reasoning / Action Plan\": {\n            \"type\": \"str\",\n            \"description\": \"Describe the decision rule and intended manipulation of elements.\",\n            # Example: 'swap if current < target'\n        },\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            break\n\nquestion: quicksort:\nkey: [0.72 0.729 0.974 0.972 0.218 0.141 0.352 0.44 0.763 0.948 0.769 0.045 0.257 0.422],\nalgorithm_schema: Question:\ninsertion_sort:\nkey: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886], \ninitial_trace: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n\n\nExample Sorting Thought: \n# --- Sorting Thought Schema ---\n\nsorting_thought_schema = {\n    \"Step Metadata\": {\n        \"Step ID\": 0,\n        \"Algorithm / Sorting Strategy\": \"Insertion\u201d\n        \"Operation Type\": \"Insert\u201d\n        \"Explanation\": \"The question calls for using insertion_sort so the primary method of sorting will be inserting into a new sorted array\n    },\n\n    \"Core State Representation\": {\n        \"Input Representation\": {\n            \"type\": \"list[Any]\u201d\n\t\u201cDescription\u201d: [0.308 0.498 0.552 0.16 0.347 0.738 0.28 0.175 0.522 0.707 0.824 0.886]\n        },\n        \"Current Stage\": {\n         \t\u201coutput_list\u201d: [],\n        },\n        \"Boundary of Sorted Region\": [0:0],\n        \"Remaining\": [0:12],\n        \"Termination Condition\": {\n            \"type\": \"bool\",\n            \"description\": \"output_list has the same length as the input and is fully sorted\"\n        },\n    },\n\n    \"Focused Action\": {\n        \"Current Element Focus\": input[0],\n        \"Comparison Target(s)\": output_list[:len(output_list)]\n        \"Operation Type\": \u201cinsert\u201d\n        \"Reasoning / Action Plan\": \"insert input[0] into the location in output_list where the subsequent output list will be sorted\u201d\n    }\n}\n\n# --- Core Iteration Process ---\n# This runnable block represents a general reasoning-based iteration process\n# for sorting using thought schema logic. It demonstrates how reasoning steps\n# could be executed dynamically without being tied to a specific algorithm.\n\ninput_state = [5, 3, 1, 4]\nprint(\"Initial State:\", input_state)\n\nfor i in range(len(input_state)):\n    current = input_state[i]             # Current Element Focus\n    comparison_targets = input_state[:i] # Comparison Targets\n    operation_type = \"compare\"           # Operation Type\n\n    # Reasoning / Action Plan:\n    # If current element is smaller than any of its previous elements,\n    # reposition it by swapping backward (insertion-like behavior).\n    for j in range(i - 1, -1, -1):\n        if input_state[j] > input_state[j + 1]:\n            # Swap operation\n            input_state[j], input_state[j + 1] = input_state[j + 1], input_state[j]\n            operation_type = \"swap\"\n        else:\n            # Already ordered correctly relative to target\n            Break\n\n<answer>[0.16 0.175 0.28 0.308 0.347 0.498 0.522 0.552 0.707 0.738 0.824 0.886]\n<\\answer> \n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0.045 0.141 0.218 0.257 0.352 0.422 0.44 0.72 0.729 0.763 0.769 0.948 0.972 0.974]"
  },
  {
    "category": "searching",
    "algorithm": "minimum",
    "question": "minimum:\nkey: [0.959 0.972 0.805 0.052 0.773 0.177 0.944 0.119 0.105 0.094 0.499 0.777 0.427 0.921 0.751 0.834 0.231 0.069 0.013 0.243 0.973 0.967 0.677 0.373 0.541 0.207 0.347 0.844 0.463 0.265 0.832 0.104 0.067 0.742 0.55 0.553 0.178 0.985 0.367 0.199 0.783 0.014 0.905 0.733 0.814 0.021 0.613 0.673 0.391 0.764 0.032], initial_trace: 0",
    "example_output_A": "18",
    "example_output_B": "18",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: minimum\nexample_output_A: 18\nexample_output_B: 18\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: minimum:\nkey: [0.959 0.972 0.805 0.052 0.773 0.177 0.944 0.119 0.105 0.094 0.499 0.777 0.427 0.921 0.751 0.834 0.231 0.069 0.013 0.243 0.973 0.967 0.677 0.373 0.541 0.207 0.347 0.844 0.463 0.265 0.832 0.104 0.067 0.742 0.55 0.553 0.178 0.985 0.367 0.199 0.783 0.014 0.905 0.733 0.814 0.021 0.613 0.673 0.391 0.764 0.032], initial_trace: 0\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "18"
  },
  {
    "category": "searching",
    "algorithm": "binary_search",
    "question": "binary_search:\nkey: [0.074 0.103 0.111 0.15 0.156 0.158 0.183 0.219 0.23 0.255 0.273 0.279 0.292 0.305 0.306 0.308 0.347 0.354 0.36 0.362 0.364 0.367 0.369 0.38 0.388 0.401 0.416 0.437 0.448 0.452 0.454 0.478 0.488 0.498 0.5 0.507 0.534 0.556 0.558 0.607 0.621 0.666 0.704 0.724 0.744 0.75 0.786 0.787 0.797 0.819 0.832 0.844 0.853 0.86 0.874 0.89 0.898 0.913 0.923 0.939 0.964 0.974], target: 0.058, initial_trace: (0, 61)",
    "example_output_A": "(0",
    "example_output_B": "(0",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: binary_search\nexample_output_A: (0\nexample_output_B: (0\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: binary_search:\nkey: [0.074 0.103 0.111 0.15 0.156 0.158 0.183 0.219 0.23 0.255 0.273 0.279 0.292 0.305 0.306 0.308 0.347 0.354 0.36 0.362 0.364 0.367 0.369 0.38 0.388 0.401 0.416 0.437 0.448 0.452 0.454 0.478 0.488 0.498 0.5 0.507 0.534 0.556 0.558 0.607 0.621 0.666 0.704 0.724 0.744 0.75 0.786 0.787 0.797 0.819 0.832 0.844 0.853 0.86 0.874 0.89 0.898 0.913 0.923 0.939 0.964 0.974], target: 0.058, initial_trace: (0, 61)\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "(0, 0)"
  },
  {
    "category": "searching",
    "algorithm": "quickselect",
    "question": "quickselect:\nkey: [0.74 0.539 0.811 0.555 0.822 0.313 0.698 0.529 0.711 0.68 0.256 0.959 0.769 0.242 0.78 0.286 0.389 0.988 0.763 0.542 0.554 0.231 0.996 0.935 0.957 0.819 0.922 0.076 0.743 0.095 0.415 0.619 0.236 0.185], initial_trace: 33",
    "example_output_A": "33",
    "example_output_B": "33",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: quickselect\nexample_output_A: 33\nexample_output_B: 5\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: quickselect:\nkey: [0.74 0.539 0.811 0.555 0.822 0.313 0.698 0.529 0.711 0.68 0.256 0.959 0.769 0.242 0.78 0.286 0.389 0.988 0.763 0.542 0.554 0.231 0.996 0.935 0.957 0.819 0.922 0.076 0.743 0.095 0.415 0.619 0.236 0.185], initial_trace: 33\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "9"
  },
  {
    "category": "divideAndConquer",
    "algorithm": "find_maximum_subarray_kadane",
    "question": "find_maximum_subarray_kadane:\nkey: [-0.451 -0.135 -0.848 0.81 0.231 -0.143 -0.406 0.107 -0.806 0.299 -0.695 -0.191 0.297 0.471 0.831 -0.882 -0.346 -0.998 0.189 0.074 0.909], initial_trace: (0, 0)",
    "example_output_A": "3)",
    "example_output_B": "3)",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: find_maximum_subarray_kadane\nexample_output_A: 3)\nexample_output_B: (12\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: 1. PROBLEM HEADER\n- algorithm: <algorithm_name>\n- input: <input_data>\n- goal: <brief one-sentence description>\n\n2. BASE CASE\nIf the input size is 0 or 1:\n    - Compute the answer directly with no recursion.\n    - Return the direct result.\n\n3. DIVIDE\nDescribe exactly how the problem is split:\n    - mid = n // 2\n    - left_part = input[0:mid]\n    - right_part = input[mid:n]\n\n4. CONQUER\nRecursively solve each subproblem:\n    - left_solution = solve(left_part)\n    - right_solution = solve(right_part)\n\n(If the algorithm requires it)\n    - cross_solution = compute_cross(input, mid)\n\n5. COMBINE\nBased on the algorithm rules, combine:\n    - choose among {left_solution, right_solution, cross_solution}\nor\n    - merge the sub-results into the final result\n\nClearly state:\n    final_result = <combined result>\n\n6. LOCAL CHECK (1-step sanity check)\nApply the divide \u2192 conquer \u2192 combine logic to a tiny example:\n    mini_input = first 2\u20133 elements of input\n    Ensure steps would produce consistent behavior.\n(No full recomputation.)\n\n7. FINAL ANSWER\nFinal Answer: <result only, no explanation>\n\nquestion: find_maximum_subarray_kadane:\nkey: [-0.451 -0.135 -0.848 0.81 0.231 -0.143 -0.406 0.107 -0.806 0.299 -0.695 -0.191 0.297 0.471 0.831 -0.882 -0.346 -0.998 0.189 0.074 0.909], initial_trace: (0, 0)\nalgorithm_schema: 1. PROBLEM HEADER\n- algorithm: Maximum Subarray (Kadane's Algorithm)\n- input: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n- goal: Find the maximum-sum contiguous subarray and return its sum.\n\n2. BASE CASE\nIf the array has size 0:\n    return 0\nIf the array has size 1:\n    return the single element\n\n3. INITIALIZE (Kadane-specific)\ncurrent_sum = input[0]\nbest_sum = input[0]\n\n4. ITERATE\nFor i from 1 to n-1:\n    current_sum = max(input[i], current_sum + input[i])\n    best_sum = max(best_sum, current_sum)\n\n5. FINAL RESULT\nfinal_result = best_sum\n\n6. LOCAL CHECK (tiny verification)\nmini_input = [-2, 1]\ncurrent_sum sequence:\n    start: -2\n    at 1: max(1, -2+1 = -1) = 1\nbest_sum becomes 1\nThis matches expected behavior.\n\n7. FINAL ANSWER\nFinal Answer: 6\n\n<answer>6</answer>\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "(12, 14)"
  },
  {
    "category": "greedy",
    "algorithm": "activity_selector",
    "question": "activity_selector:\ns: [0.244 0.367 0.241 0.504 0.719 0.334 0.145 0.307 0.542 0.057 0.323 0.042 0.322 0.332 0.462 0.795 0.03 0.375 0.116 0.205 0.677 0.497 0.613 0.018 0.569 0.097 0.301], f: [0.948 0.518 0.734 0.675 0.763 0.901 0.567 0.925 0.831 0.916 0.842 0.685 0.613 0.901 0.875 0.842 0.13 0.657 0.18 0.838 0.677 0.958 0.756 0.407 0.826 0.726 0.85],",
    "example_output_A": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0]",
    "example_output_B": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: activity_selector\nexample_output_A: [0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0]\nexample_output_B: [0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: Input\nalgorithm: <algorithm_name>                 \ngoal: <maximize_or_minimize>                \nitems: [                                     \n  { <feature1>: ..., <feature2>: ..., ... },\n  ...\n]\nexample_output: [...]                        \n\nStep 1: Initialize Variables\nn = number_of(items)\nselected = []\nstate = {}                                    \n\n# Define any problem-specific initial state\n# Examples:\n# state[\"last_finish\"] = -inf\n# state[\"remaining_capacity\"] = C\n# state[\"remaining_amount\"] = amount\n\nStep 2: Define Greedy Criterion\n# Step 2a: scoring rule\ndefine greedy_key(item):\n    return <feature used to rank items>\n\n# Step 2b: sort\nitems_sorted = sort(items, by=greedy_key)\n\n# Optional one-sentence rationale.\n\nStep 3: Define Feasibility Condition\ndefine feasible(item, state):\n    return <boolean feasibility condition>\n\n# Examples:\n# item.start >= state[\"last_finish\"]\n# item.value <= state[\"remaining_amount\"]\n\nStep 4: Iterate Through Items\nfor item in items_sorted:\n    if feasible(item, state):\n        selected.append(item)\n        update state using item\n        # e.g., state[\"last_finish\"] = item.finish\n\nStep 5: Optional Verification\n# Use a tiny example (\u22643 items) to verify\n# the greedy rule and feasibility logic.\n\nStep 6: Return Final Output\ntotal_value = compute_value(selected)\nreturn {\n  \"selected\": selected,\n  \"total_value\": total_value,\n  \"state\": state\n}\n\nquestion: activity_selector:\ns: [0.244 0.367 0.241 0.504 0.719 0.334 0.145 0.307 0.542 0.057 0.323 0.042 0.322 0.332 0.462 0.795 0.03 0.375 0.116 0.205 0.677 0.497 0.613 0.018 0.569 0.097 0.301], f: [0.948 0.518 0.734 0.675 0.763 0.901 0.567 0.925 0.831 0.916 0.842 0.685 0.613 0.901 0.875 0.842 0.13 0.657 0.18 0.838 0.677 0.958 0.756 0.407 0.826 0.726 0.85],\nalgorithm_schema: Input\nalgorithm: \"Activity Selection\"\ngoal: \"maximize number of non-overlapping activities\"\nitems: [\n  {start: 1, finish: 2},\n  {start: 3, finish: 4},\n  {start: 0, finish: 6},\n  {start: 5, finish: 7},\n  {start: 8, finish: 9},\n  {start: 5, finish: 9}\n]\nexample_output: [0, 1, 3, 4]\n\nStep 1: Initialize Variables\nn = 6\nselected = []\nstate = {\"last_finish\": -inf}\n\nStep 2: Define Greedy Criterion\ndefine greedy_key(item):\n    return item.finish\n\nitems_sorted =\n[\n  {start:1,finish:2},   # index 0\n  {start:3,finish:4},   # index 1\n  {start:5,finish:7},   # index 3\n  {start:0,finish:6},   # index 2\n  {start:8,finish:9},   # index 4\n  {start:5,finish:9}    # index 5\n]\n\n# Rationale: earliest finishing activity leaves maximum room.\n\nStep 3: Define Feasibility\ndefine feasible(item, state):\n    return item.start >= state[\"last_finish\"]\n\nStep 4: Iterate\nitem 0 \u2192 start=1 >= -inf \u2192 select \u2192 last_finish=2\nitem 1 \u2192 start=3 >= 2   \u2192 select \u2192 last_finish=4\nitem 3 \u2192 start=5 >= 4   \u2192 select \u2192 last_finish=7\nitem 2 \u2192 start=0 < 7    \u2192 skip\nitem 4 \u2192 start=8 >= 7   \u2192 select \u2192 last_finish=9\nitem 5 \u2192 start=5 < 9    \u2192 skip\n\nStep 6: Final Output\n{\n  \"selected\": [0, 1, 3, 4],\n  \"total_value\": null,\n  \"state\": {\"last_finish\": 9}\n}\n\n<answer>[0 1 0 1 1 0]</answer>\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0]"
  },
  {
    "category": "greedy",
    "algorithm": "task_scheduling",
    "question": "task_scheduling:\nd: [15 15 14 28 11 30 12 1 25 15 21 23 12 25 16 1 16 12 27 26 34 20 14 4 22 18 32 20 28 1 28 23 12 8], w: [0.386 0.499 0.472 0.885 0.902 0.989 0.521 0.281 0.12 0.018 0.093 0.938 0.225 0.205 0.579 0.825 0.809 0.176 0.629 0.753 0.094 0.709 0.348 0.61 0.091 0.425 0.382 0.684 0.284 0.761 0.434 0.54 0.928 0.019],",
    "example_output_A": "[0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 0 1 1 1 0]",
    "example_output_B": "[0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 0 1 1 1 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: task_scheduling\nexample_output_A: [0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 0 1 1 1 0]\nexample_output_B: [0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 0 1 0 0 0 1 1 1 1 0 1 1 1 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: Input\nalgorithm: <algorithm_name>                 \ngoal: <maximize_or_minimize>                \nitems: [                                     \n  { <feature1>: ..., <feature2>: ..., ... },\n  ...\n]\nexample_output: [...]                        \n\nStep 1: Initialize Variables\nn = number_of(items)\nselected = []\nstate = {}                                    \n\n# Define any problem-specific initial state\n# Examples:\n# state[\"last_finish\"] = -inf\n# state[\"remaining_capacity\"] = C\n# state[\"remaining_amount\"] = amount\n\nStep 2: Define Greedy Criterion\n# Step 2a: scoring rule\ndefine greedy_key(item):\n    return <feature used to rank items>\n\n# Step 2b: sort\nitems_sorted = sort(items, by=greedy_key)\n\n# Optional one-sentence rationale.\n\nStep 3: Define Feasibility Condition\ndefine feasible(item, state):\n    return <boolean feasibility condition>\n\n# Examples:\n# item.start >= state[\"last_finish\"]\n# item.value <= state[\"remaining_amount\"]\n\nStep 4: Iterate Through Items\nfor item in items_sorted:\n    if feasible(item, state):\n        selected.append(item)\n        update state using item\n        # e.g., state[\"last_finish\"] = item.finish\n\nStep 5: Optional Verification\n# Use a tiny example (\u22643 items) to verify\n# the greedy rule and feasibility logic.\n\nStep 6: Return Final Output\ntotal_value = compute_value(selected)\nreturn {\n  \"selected\": selected,\n  \"total_value\": total_value,\n  \"state\": state\n}\n\nquestion: task_scheduling:\nd: [15 15 14 28 11 30 12 1 25 15 21 23 12 25 16 1 16 12 27 26 34 20 14 4 22 18 32 20 28 1 28 23 12 8], w: [0.386 0.499 0.472 0.885 0.902 0.989 0.521 0.281 0.12 0.018 0.093 0.938 0.225 0.205 0.579 0.825 0.809 0.176 0.629 0.753 0.094 0.709 0.348 0.61 0.091 0.425 0.382 0.684 0.284 0.761 0.434 0.54 0.928 0.019],\nalgorithm_schema: Input\nalgorithm: \"Activity Selection\"\ngoal: \"maximize number of non-overlapping activities\"\nitems: [\n  {start: 1, finish: 2},\n  {start: 3, finish: 4},\n  {start: 0, finish: 6},\n  {start: 5, finish: 7},\n  {start: 8, finish: 9},\n  {start: 5, finish: 9}\n]\nexample_output: [0, 1, 3, 4]\n\nStep 1: Initialize Variables\nn = 6\nselected = []\nstate = {\"last_finish\": -inf}\n\nStep 2: Define Greedy Criterion\ndefine greedy_key(item):\n    return item.finish\n\nitems_sorted =\n[\n  {start:1,finish:2},   # index 0\n  {start:3,finish:4},   # index 1\n  {start:5,finish:7},   # index 3\n  {start:0,finish:6},   # index 2\n  {start:8,finish:9},   # index 4\n  {start:5,finish:9}    # index 5\n]\n\n# Rationale: earliest finishing activity leaves maximum room.\n\nStep 3: Define Feasibility\ndefine feasible(item, state):\n    return item.start >= state[\"last_finish\"]\n\nStep 4: Iterate\nitem 0 \u2192 start=1 >= -inf \u2192 select \u2192 last_finish=2\nitem 1 \u2192 start=3 >= 2   \u2192 select \u2192 last_finish=4\nitem 3 \u2192 start=5 >= 4   \u2192 select \u2192 last_finish=7\nitem 2 \u2192 start=0 < 7    \u2192 skip\nitem 4 \u2192 start=8 >= 7   \u2192 select \u2192 last_finish=9\nitem 5 \u2192 start=5 < 9    \u2192 skip\n\nStep 6: Final Output\n{\n  \"selected\": [0, 1, 3, 4],\n  \"total_value\": null,\n  \"state\": {\"last_finish\": 9}\n}\n\n<answer>[0 1 0 1 1 0]</answer>\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 1 1 1 1 1 0 0 1 0 0 1 0 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 1 0 1 1 1 0]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "matrix_chain_order",
    "question": "matrix_chain_order:\np: [0.872 0.642 0.651 0.311 0.48 0.57 0.5 0.49 0.872 0.458 0.951 0.715 0.387],",
    "example_output_A": "[0 0 0 0 0 0 0 6 0 0 0 0 0]",
    "example_output_B": "[0 0 0 0 0 0 0 6 0 0 0 0 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: matrix_chain_order\nexample_output_A: [0 0 0 0 0 0 0 6 0 0 0 0 0]\nexample_output_B: [0 0 0 0 0 0 0 0 0 8 0 0 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: matrix_chain_order:\np: [0.872 0.642 0.651 0.311 0.48 0.57 0.5 0.49 0.872 0.458 0.951 0.715 0.387],\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 1 1 3 3 3 3 3 3 3 3 3], [0 0 0 2 3 3 3 3 3 3 3 3 3], [0 0 0 0 3 3 3 3 3 3 3 3 3], [0 0 0 0 0 4 5 6 7 8 9 10 11], [0 0 0 0 0 0 5 6 7 6 9 9 5], [0 0 0 0 0 0 0 6 7 6 9 9 6], [0 0 0 0 0 0 0 0 7 7 9 9 7], [0 0 0 0 0 0 0 0 0 8 9 9 9], [0 0 0 0 0 0 0 0 0 0 9 9 9], [0 0 0 0 0 0 0 0 0 0 0 10 10], [0 0 0 0 0 0 0 0 0 0 0 0 11], [0 0 0 0 0 0 0 0 0 0 0 0 0]]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "lcs_length",
    "question": "lcs_length:\nstring: [0 0 0 0 0 0 0 1 1 1 1 1 1], key: [2 2 2 1 3 0 2 2 1 3 2 0 2],",
    "example_output_A": "[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]",
    "example_output_B": "[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: lcs_length\nexample_output_A: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]\nexample_output_B: [[-1 -1 -1 -1 -1 -1 -1 0 2 2 0 2 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: lcs_length:\nstring: [0 0 0 0 0 0 0 1 1 1 1 1 1], key: [2 2 2 1 3 0 2 2 1 3 2 0 2],\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[-1 -1 -1 -1 -1 -1 -1 0 2 2 0 2 0], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 2 0], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 1 0], [-1 -1 -1 -1 -1 -1 -1 1 0 2 1 1 1], [-1 -1 -1 -1 -1 -1 -1 1 1 0 2 2 1], [-1 -1 -1 -1 -1 -1 -1 1 1 1 1 0 2], [-1 -1 -1 -1 -1 -1 -1 0 1 1 0 1 0], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1], [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]]"
  },
  {
    "category": "dynamicProgramming",
    "algorithm": "optimal_bst",
    "question": "optimal_bst:\np: [0.035 0.076 0.085 0.011 0.06 0.065 0.031 0], q: [0.089 0.011 0.104 0.072 0.062 0.138 0.135 0.025],",
    "example_output_A": "[0 0 0 0 3 4 4 5]",
    "example_output_B": "[0 0 0 0 3 4 4 5]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: optimal_bst\nexample_output_A: [0 0 0 0 3 4 4 5]\nexample_output_B: [0 0 0 0 0 0 5 5]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: optimal_bst:\np: [0.035 0.076 0.085 0.011 0.06 0.065 0.031 0], q: [0.089 0.011 0.104 0.072 0.062 0.138 0.135 0.025],\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[0 0 1 1 2 2 2 4], [0 0 1 2 2 2 4 4], [0 0 0 2 2 4 4 4], [0 0 0 0 3 4 4 5], [0 0 0 0 0 4 5 5], [0 0 0 0 0 0 5 5], [0 0 0 0 0 0 0 6], [0 0 0 0 0 0 0 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "dfs",
    "question": "dfs:\nA: [[0 1 0 0 0 1 1], [0 1 1 0 0 1 0], [1 0 1 0 0 1 1], [1 1 1 0 1 1 1], [1 0 1 0 0 1 1], [1 1 0 0 0 0 0], [1 1 1 0 1 0 1]],",
    "example_output_A": "[0 0 1 3 6 2 2]",
    "example_output_B": "[0 0 1 3 6 2 2]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: dfs\nexample_output_A: [0 0 1 3 6 2 2]\nexample_output_B: [0 0 1 3 4 2 2]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: dfs:\nA: [[0 1 0 0 0 1 1], [0 1 1 0 0 1 0], [1 0 1 0 0 1 1], [1 1 1 0 1 1 1], [1 0 1 0 0 1 1], [1 1 0 0 0 0 0], [1 1 1 0 1 0 1]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 0 1 3 6 2 2]"
  },
  {
    "category": "graphs",
    "algorithm": "bfs",
    "question": "bfs:\ns: 6, A: [[0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 0 0 1 0 1], [1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1 1 0 1 0 1 0 0 0 1 0 0 0], [0 1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1], [1 1 0 1 1 0 1 1 0 0 1 1 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 1 0 0 0 1 1 1 0 0 0 0], [0 1 0 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0], [0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 0 0 1 0 1 0 0 0 0 1 0 0 0], [0 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0], [1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 1 0 0], [0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1], [0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0], [0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 0], [0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 0], [0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0], [0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1], [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0], [1 1 0 1 0 1 0 1 0 0 1 1 0 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0], [0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0], [1 0 1 0 0 1 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0], [0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1], [0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0], [1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0], [1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0], [1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0], [1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0], [0 1 0 0 0 1 1 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0], [0 0 1 1 0 1 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 1 0 0 0], [0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0], [0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0], [0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 1 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0], [0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 0 0 1 0], [0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 0], [1 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0], [0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1], [0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0], [0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]],",
    "example_output_A": "[0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]",
    "example_output_B": "[0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: bfs\nexample_output_A: [0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]\nexample_output_B: [0 6 2 3 4 6 6 7 8 9 6 11 12 6 14 6 16 17 18 6 20 21 22 23 6 6 26 6 28 29 30 31 6 33 6 35 6 37 38 6 40 41 42 43 44 45 46 47 6 6 50 51]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: bfs:\ns: 6, A: [[0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 0 0 0 1 0 1], [1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1 1 0 1 0 1 0 0 0 1 0 0 0], [0 1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1], [1 1 0 1 1 0 1 1 0 0 1 1 1 0 0 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 0 1 1 0 0 0 1 1 1 0 0 0 0], [0 1 0 0 0 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0], [0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 1 1 1 1 0 1 1 0 0 1 0 1 0 0 0 0 1 0 0 0], [0 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0], [1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 1 0 1 0 0], [0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1], [0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0], [0 1 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 1 1 1 0], [0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 0], [0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0], [0 1 0 1 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 1 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1], [0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0], [1 1 0 1 0 1 0 1 0 0 1 1 0 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 1 0 0 1 0 0 1 1 0], [0 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0], [1 0 1 0 0 1 0 1 0 1 1 1 1 0 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 1 0 0 1 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 0 1 0 0], [0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 0 0 0 0 1], [0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0], [1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0], [1 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0], [1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0], [1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0], [0 1 0 0 0 1 1 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 1 0 0 1 1 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0], [0 0 1 1 0 1 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0 1 0 0 0], [0 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0], [0 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0], [0 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 1 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0], [0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 0 0 1 0], [0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 0 0 0], [1 1 0 1 0 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 0], [0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1], [0 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0], [0 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[5 6 25 5 1 6 6 5 24 36 6 5 5 6 10 6 5 1 25 6 15 1 10 5 6 6 1 6 10 1 10 13 6 1 6 5 6 1 1 6 5 5 1 1 1 5 5 5 6 6 10 1]"
  },
  {
    "category": "graphs",
    "algorithm": "topological_sort",
    "question": "topological_sort:\nA: [[0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 0 0 0], [1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0], [0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0], [1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 1 0], [1 1 1 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 1 1], [1 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0], [1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0], [0 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0], [1 1 1 1 0 1 1 0 0 1 1 1 1 1 0 1 1 0 0 1 1 0 0 1 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0], [0 1 1 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0], [0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 1 1 1 1 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 1 1 1 0]], initial_trace: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26], 0",
    "example_output_A": "[0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]",
    "example_output_B": "[0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: topological_sort\nexample_output_A: [0 1 2 3 4 5 22 5 6 9 10 11 12 13 14 8 16 17 18 19 20 21 7 23 24 25 26]\nexample_output_B: [19 0 24 3 4 5 22 5 6 10 2 11 12 23 21 8 1 17 15 20 18 9 7 16 25 13 26]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: topological_sort:\nA: [[0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 0 0 0], [1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 1 1 1 0], [0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0], [0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0], [1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 0 1 1 0 0 0 1 1 1 0], [1 1 1 0 0 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0 0 0 0 1 1], [1 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0], [1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0], [0 1 1 0 0 0 1 0 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [1 0 0 0 0 1 0 1 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0], [1 1 1 1 0 1 1 0 0 1 1 1 1 1 0 1 1 0 0 1 1 0 0 1 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0], [0 1 1 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 1 1 1 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0], [1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0], [0 0 0 0 0 0 0 1 1 0 0 0 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0], [1 1 0 0 1 1 1 1 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 1 1 1 0]], initial_trace: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26], 0\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[19 0 24 14 3 5 22 5 6 10 2 26 4 23 21 8 1 11 15 20 18 9 7 16 25 13 12], 17"
  },
  {
    "category": "graphs",
    "algorithm": "articulation_points",
    "question": "articulation_points:\nA: [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0], [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],",
    "example_output_A": "[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]",
    "example_output_B": "[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: articulation_points\nexample_output_A: [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]\nexample_output_B: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: articulation_points:\nA: [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0], [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0], [0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0]"
  },
  {
    "category": "graphs",
    "algorithm": "bridges",
    "question": "bridges:\nA: [[0 0 0 0 0 0 0 0], [0 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0]],",
    "example_output_A": "[-1 -1 -1 -1 0 -1 -1 -1]",
    "example_output_B": "[-1 -1 -1 -1 0 -1 -1 -1]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: bridges\nexample_output_A: [-1 -1 -1 -1 0 -1 -1 -1]\nexample_output_B: [-1 -1 0 -1 -1 -1 -1 -1]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: bridges:\nA: [[0 0 0 0 0 0 0 0], [0 1 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 1 0 0], [0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[0 -1 -1 -1 -1 -1 -1 -1], [-1 0 -1 -1 -1 -1 -1 -1], [-1 -1 0 -1 -1 -1 -1 -1], [-1 -1 -1 0 -1 -1 -1 -1], [-1 -1 -1 -1 0 -1 -1 -1], [-1 -1 -1 -1 -1 0 -1 -1], [-1 -1 -1 -1 -1 -1 0 -1], [-1 -1 -1 -1 -1 -1 -1 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "strongly_connected_components",
    "question": "strongly_connected_components:\nA: [[1 1 0 0 0 0], [1 1 0 0 1 0], [0 0 1 0 0 0], [0 0 0 0 1 0], [0 0 0 0 1 0], [0 0 0 0 0 0]],",
    "example_output_A": "[0 1 2 3 4 5]",
    "example_output_B": "[0 1 2 3 4 5]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: strongly_connected_components\nexample_output_A: [0 1 2 3 4 5]\nexample_output_B: [0 1 2 3 4 5]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: strongly_connected_components:\nA: [[1 1 0 0 0 0], [1 1 0 0 1 0], [0 0 1 0 0 0], [0 0 0 0 1 0], [0 0 0 0 1 0], [0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 0 2 3 4 5]"
  },
  {
    "category": "graphs",
    "algorithm": "mst_kruskal",
    "question": "mst_kruskal:\nA: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]],",
    "example_output_A": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]",
    "example_output_B": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: mst_kruskal\nexample_output_A: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]\nexample_output_B: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: mst_kruskal:\nA: [[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0], [0 0 0 0 0 0]]"
  },
  {
    "category": "graphs",
    "algorithm": "mst_prim",
    "question": "mst_prim:\ns: 14, A: [[0.726 0 0 0 0 0 0.972 0.268 0 0.561 0 0 0 0.432 0 0], [0 0 0 0 0.762 0 0 0.538 0 0 0.334 0 0 0 0.151 0.925], [0 0 0 0.276 0 0.438 0 0.732 0 0 0.77 0 0 0 0 0], [0 0 0.276 0.952 0 0.185 0 0 0 0 0 0 0 0 0 0], [0 0.762 0 0 0.887 0 0 0 0 0 0 0 0.363 0 0 0], [0 0 0.438 0.185 0 0.033 0 0.295 0.345 0.079 0 0 0 0.117 0 0], [0.972 0 0 0 0 0 0 0.938 0 0.308 0 0 0 0 0.655 0], [0.268 0.538 0.732 0 0 0.295 0.938 0.599 0 0 0 0.125 0 0 0 0], [0 0 0 0 0 0.345 0 0 0.678 0 0 0 0.219 0 0.144 0.573], [0.561 0 0 0 0 0.079 0.308 0 0 0 0 0 0 0 0 0], [0 0.334 0.77 0 0 0 0 0 0 0 0 0.855 0 0.257 0 0], [0 0 0 0 0 0 0 0.125 0 0 0.855 0 0 0.591 0.057 0], [0 0 0 0 0.363 0 0 0 0.219 0 0 0 0.582 0 0 0], [0.432 0 0 0 0 0.117 0 0 0 0 0.257 0.591 0 0.893 0 0.269], [0 0.151 0 0 0 0 0.655 0 0.144 0 0 0.057 0 0 0 0.041], [0 0.925 0 0 0 0 0 0 0.573 0 0 0 0 0.269 0.041 0.185]],",
    "example_output_A": "[7 14 7 3 12 7 14 11 14 0 1 14 8 15 14 14]",
    "example_output_B": "[7 14 7 3 12 7 14 11 14 0 1 14 8 15 14 14]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: mst_prim\nexample_output_A: [7 14 7 3 12 7 14 11 14 0 1 14 8 15 14 14]\nexample_output_B: [7 14 7 3 12 7 14 11 14 9 1 14 8 15 14 14]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: mst_prim:\ns: 14, A: [[0.726 0 0 0 0 0 0.972 0.268 0 0.561 0 0 0 0.432 0 0], [0 0 0 0 0.762 0 0 0.538 0 0 0.334 0 0 0 0.151 0.925], [0 0 0 0.276 0 0.438 0 0.732 0 0 0.77 0 0 0 0 0], [0 0 0.276 0.952 0 0.185 0 0 0 0 0 0 0 0 0 0], [0 0.762 0 0 0.887 0 0 0 0 0 0 0 0.363 0 0 0], [0 0 0.438 0.185 0 0.033 0 0.295 0.345 0.079 0 0 0 0.117 0 0], [0.972 0 0 0 0 0 0 0.938 0 0.308 0 0 0 0 0.655 0], [0.268 0.538 0.732 0 0 0.295 0.938 0.599 0 0 0 0.125 0 0 0 0], [0 0 0 0 0 0.345 0 0 0.678 0 0 0 0.219 0 0.144 0.573], [0.561 0 0 0 0 0.079 0.308 0 0 0 0 0 0 0 0 0], [0 0.334 0.77 0 0 0 0 0 0 0 0 0.855 0 0.257 0 0], [0 0 0 0 0 0 0 0.125 0 0 0.855 0 0 0.591 0.057 0], [0 0 0 0 0.363 0 0 0 0.219 0 0 0 0.582 0 0 0], [0.432 0 0 0 0 0.117 0 0 0 0 0.257 0.591 0 0.893 0 0.269], [0 0.151 0 0 0 0 0.655 0 0.144 0 0 0.057 0 0 0 0.041], [0 0.925 0 0 0 0 0 0 0.573 0 0 0 0 0.269 0.041 0.185]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[7 14 3 5 12 13 9 11 14 5 13 14 8 15 14 14]"
  },
  {
    "category": "graphs",
    "algorithm": "bellman_ford",
    "question": "bellman_ford:\ns: 19, A: [[0 0 0 0 0.456 0 0 0 0 0 0 0.218 0 0 0 0 0 0.216 0 0.051 0 0 0.202 0.395 0], [0 0 0 0 0.362 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.897 0 0.312 0 0], [0 0 0.906 0 0 0 0 0 0 0.635 0 0 0 0.488 0 0 0 0 0 0 0 0 0 0.208 0], [0 0 0 0 0 0 0 0 0 0 0 0.738 0 0.277 0 0 0 0 0 0.59 0.233 0 0 0.474 0], [0.456 0.362 0 0 0 0 0 0 0.466 0 0.594 0 0.302 0 0 0 0.347 0 0 0 0 0 0 0 0], [0 0 0 0 0 0.69 0 0 0 0 0.529 0 0.308 0 0 0 0.387 0 0.574 0 0 0 0.599 0.438 0.402], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.042 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.433 0 0 0.688 0 0 0.633 0 0.17 0 0 0.184 0.338 0 0.151 0.529 0 0.143], [0 0 0 0 0.466 0 0 0 0 0 0 0 0 0 0.444 0 0 0 0 0 0 0 0 0 0.551], [0 0 0.635 0 0 0 0 0 0 0.844 0.904 0 0.075 0 0 0.344 0 0 0.125 0 0 0 0 0 0], [0 0 0 0 0.594 0.529 0 0.688 0 0.904 0.336 0 0.581 0 0 0 0.243 0 0 0.507 0 0 0 0 0], [0.218 0 0 0.738 0 0 0 0 0 0 0 0 0 0 0.643 0 0.224 0.491 0.477 0 0.039 0.518 0 0 0], [0 0 0 0 0.302 0.308 0 0 0 0.075 0.581 0 0.946 0 0.761 0 0 0 0.157 0 0 0 0 0 0], [0 0 0.488 0.277 0 0 0 0.633 0 0 0 0 0 0.166 0 0.752 0 0 0.186 0 0.254 0.472 0 0 0], [0 0 0 0 0 0 0 0 0.444 0 0 0.643 0.761 0 0.391 0 0 0 0 0.085 0.554 0 0 0 0], [0 0 0 0 0 0 0 0.17 0 0.344 0 0 0 0.752 0 0.09 0 0 0 0 0.731 0 0 0 0], [0 0 0 0 0.347 0.387 0 0 0 0 0.243 0.224 0 0 0 0 0.631 0 0 0 0.405 0 0 0 0], [0.216 0 0 0 0 0 0 0 0 0 0 0.491 0 0 0 0 0 0 0.59 0 0.617 0 0 0.149 0], [0 0 0 0 0 0.574 0.042 0.184 0 0.125 0 0.477 0.157 0.186 0 0 0 0.59 0 0 0 0 0 0 0], [0.051 0 0 0.59 0 0 0 0.338 0 0 0.507 0 0 0 0.085 0 0 0 0 0.184 0 0 0.32 0 0], [0 0.897 0 0.233 0 0 0 0 0 0 0 0.039 0 0.254 0.554 0.731 0.405 0.617 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.151 0 0 0 0.518 0 0.472 0 0 0 0 0 0 0 0.901 0 0 0], [0.202 0.312 0 0 0 0.599 0 0.529 0 0 0 0 0 0 0 0 0 0 0 0.32 0 0 0.653 0 0.411], [0.395 0 0.208 0.474 0 0.438 0 0 0 0 0 0 0 0 0 0 0 0.149 0 0 0 0 0 0 0], [0 0 0 0 0 0.402 0 0.143 0.551 0 0 0 0 0 0 0 0 0 0 0 0 0 0.411 0 0]],",
    "example_output_A": "[19 22 2 19 0 22 6 19 14 10 19 0 14 3 19 7 10 0 7 19 14 7 0 0 7]",
    "example_output_B": "[19 22 2 19 0 22 6 19 14 10 19 0 14 3 19 7 10 0 7 19 14 7 0 0 7]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: bellman_ford\nexample_output_A: [19 22 2 19 0 22 6 19 14 10 19 0 14 3 19 7 10 0 7 19 14 7 0 0 7]\nexample_output_B: [19 22 2 19 0 22 6 19 14 10 19 0 14 3 19 7 10 0 7 19 14 7 0 0 7]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: bellman_ford:\ns: 19, A: [[0 0 0 0 0.456 0 0 0 0 0 0 0.218 0 0 0 0 0 0.216 0 0.051 0 0 0.202 0.395 0], [0 0 0 0 0.362 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.897 0 0.312 0 0], [0 0 0.906 0 0 0 0 0 0 0.635 0 0 0 0.488 0 0 0 0 0 0 0 0 0 0.208 0], [0 0 0 0 0 0 0 0 0 0 0 0.738 0 0.277 0 0 0 0 0 0.59 0.233 0 0 0.474 0], [0.456 0.362 0 0 0 0 0 0 0.466 0 0.594 0 0.302 0 0 0 0.347 0 0 0 0 0 0 0 0], [0 0 0 0 0 0.69 0 0 0 0 0.529 0 0.308 0 0 0 0.387 0 0.574 0 0 0 0.599 0.438 0.402], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.042 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.433 0 0 0.688 0 0 0.633 0 0.17 0 0 0.184 0.338 0 0.151 0.529 0 0.143], [0 0 0 0 0.466 0 0 0 0 0 0 0 0 0 0.444 0 0 0 0 0 0 0 0 0 0.551], [0 0 0.635 0 0 0 0 0 0 0.844 0.904 0 0.075 0 0 0.344 0 0 0.125 0 0 0 0 0 0], [0 0 0 0 0.594 0.529 0 0.688 0 0.904 0.336 0 0.581 0 0 0 0.243 0 0 0.507 0 0 0 0 0], [0.218 0 0 0.738 0 0 0 0 0 0 0 0 0 0 0.643 0 0.224 0.491 0.477 0 0.039 0.518 0 0 0], [0 0 0 0 0.302 0.308 0 0 0 0.075 0.581 0 0.946 0 0.761 0 0 0 0.157 0 0 0 0 0 0], [0 0 0.488 0.277 0 0 0 0.633 0 0 0 0 0 0.166 0 0.752 0 0 0.186 0 0.254 0.472 0 0 0], [0 0 0 0 0 0 0 0 0.444 0 0 0.643 0.761 0 0.391 0 0 0 0 0.085 0.554 0 0 0 0], [0 0 0 0 0 0 0 0.17 0 0.344 0 0 0 0.752 0 0.09 0 0 0 0 0.731 0 0 0 0], [0 0 0 0 0.347 0.387 0 0 0 0 0.243 0.224 0 0 0 0 0.631 0 0 0 0.405 0 0 0 0], [0.216 0 0 0 0 0 0 0 0 0 0 0.491 0 0 0 0 0 0 0.59 0 0.617 0 0 0.149 0], [0 0 0 0 0 0.574 0.042 0.184 0 0.125 0 0.477 0.157 0.186 0 0 0 0.59 0 0 0 0 0 0 0], [0.051 0 0 0.59 0 0 0 0.338 0 0 0.507 0 0 0 0.085 0 0 0 0 0.184 0 0 0.32 0 0], [0 0.897 0 0.233 0 0 0 0 0 0 0 0.039 0 0.254 0.554 0.731 0.405 0.617 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.151 0 0 0 0.518 0 0.472 0 0 0 0 0 0 0 0.901 0 0 0], [0.202 0.312 0 0 0 0.599 0 0.529 0 0 0 0 0 0 0 0 0 0 0 0.32 0 0 0.653 0 0.411], [0.395 0 0.208 0.474 0 0.438 0 0 0 0 0 0 0 0 0 0 0 0.149 0 0 0 0 0 0 0], [0 0 0 0 0 0.402 0 0.143 0.551 0 0 0 0 0 0 0 0 0 0 0 0 0 0.411 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[19 22 23 20 0 22 18 19 14 18 19 0 18 20 19 7 11 0 7 19 11 7 0 17 7]"
  },
  {
    "category": "graphs",
    "algorithm": "dijkstra",
    "question": "dijkstra:\ns: 3, A: [[0.139 0 0 0 0.206 0], [0 0 0 0 0 0.219], [0 0 0 0 0 0.598], [0 0 0 0 0 0], [0.206 0 0 0 0 0], [0 0.219 0.598 0 0 0.653]],",
    "example_output_A": "[0 1 2 3 4 5]",
    "example_output_B": "[0 1 2 3 4 5]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: dijkstra\nexample_output_A: [0 1 2 3 4 5]\nexample_output_B: [0 1 2 3 4 5]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: dijkstra:\ns: 3, A: [[0.139 0 0 0 0.206 0], [0 0 0 0 0 0.219], [0 0 0 0 0 0.598], [0 0 0 0 0 0], [0.206 0 0 0 0 0], [0 0.219 0.598 0 0 0.653]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 1 2 3 4 5]"
  },
  {
    "category": "graphs",
    "algorithm": "dag_shortest_paths",
    "question": "dag_shortest_paths:\ns: 7, A: [[0 0.836 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0.502 0 0 0 0 0 0.512 0 0 0 0 0 0.925 0 0.321 0 0 0.913 0 0 0], [0.136 0 0 0 0 0 0 0 0 0 0 0 0 0.53 0 0 0 0 0 0 0.407 0 0 0.427], [0.237 0.943 0 0 0 0 0 0 0.00731 0.691 0 0 0 0.944 0 0 0.984 0.0368 0.875 0.678 0 0 0.947 0.627], [0.799 0.973 0 0.353 0 0 0 0 0.197 0.186 0 0.552 0.205 0 0 0 0 0 0 0.864 0 0 0.695 0], [0.826 0 0.607 0.736 0.497 0.238 0 0.397 0.305 0 0 0.0632 0 0.597 0 0.441 0 0.166 0 0 0.877 0 0.205 0], [0.823 0.769 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.464 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.976 0], [0.444 0 0 0 0 0 0 0 0 0 0 0 0 0.448 0 0 0 0 0 0.372 0 0 0 0.915], [0 0.664 0 0.779 0 0 0 0 0.673 0 0 0.144 0.849 0 0 0.0344 0.325 0 0 0 0.434 0 0.799 0], [0 0.622 0 0.382 0.895 0 0 0.111 0.338 0 0 0 0 0.68 0 0.351 0 0 0.561 0 0 0 0 0], [0 0.562 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0636 0 0 0 0 0 0.811], [0 0.144 0 0 0 0 0 0 0.583 0 0 0 0 0 0 0 0 0 0.853 0 0 0 0 0], [0 0 0.115 0.79 0 0 0 0.628 0.784 0.0645 0.783 0.00649 0 0.244 0 0.151 0.928 0.741 0.188 0 0.855 0 0 0], [0.617 0.549 0 0 0 0 0 0.268 0.193 0.116 0 0 0 0 0 0 0.901 0 0 0 0 0 0 0], [0 0.807 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0398 0.814], [0 0.114 0 0 0 0 0 0.698 0 0 0 0 0 0 0 0 0 0 0 0.0662 0 0 0.721 0.277], [0.911 0.823 0 0 0 0 0 0.598 0 0 0 0 0 0 0 0 0 0 0 0.281 0.207 0 0.0694 0.622], [0.221 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.405 0], [0 0.448 0 0 0 0 0 0.605 0.334 0 0 0 0 0 0 0 0 0 0 0.979 0 0 0 0.689], [0 0.538 0 0.115 0.238 0 0 0.927 0.748 0.205 0 0.404 0 0.101 0 0.58 0 0 0.218 0.132 0.356 0 0.0234 0], [0.23 0.0832 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0.719 0 0 0 0 0 0 0.721 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],",
    "example_output_A": "[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]",
    "example_output_B": "[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: dag_shortest_paths\nexample_output_A: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\nexample_output_B: [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: dag_shortest_paths:\ns: 7, A: [[0 0.836 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0.502 0 0 0 0 0 0.512 0 0 0 0 0 0.925 0 0.321 0 0 0.913 0 0 0], [0.136 0 0 0 0 0 0 0 0 0 0 0 0 0.53 0 0 0 0 0 0 0.407 0 0 0.427], [0.237 0.943 0 0 0 0 0 0 0.00731 0.691 0 0 0 0.944 0 0 0.984 0.0368 0.875 0.678 0 0 0.947 0.627], [0.799 0.973 0 0.353 0 0 0 0 0.197 0.186 0 0.552 0.205 0 0 0 0 0 0 0.864 0 0 0.695 0], [0.826 0 0.607 0.736 0.497 0.238 0 0.397 0.305 0 0 0.0632 0 0.597 0 0.441 0 0.166 0 0 0.877 0 0.205 0], [0.823 0.769 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0 0 0 0 0 0 0 0.464 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.976 0], [0.444 0 0 0 0 0 0 0 0 0 0 0 0 0.448 0 0 0 0 0 0.372 0 0 0 0.915], [0 0.664 0 0.779 0 0 0 0 0.673 0 0 0.144 0.849 0 0 0.0344 0.325 0 0 0 0.434 0 0.799 0], [0 0.622 0 0.382 0.895 0 0 0.111 0.338 0 0 0 0 0.68 0 0.351 0 0 0.561 0 0 0 0 0], [0 0.562 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0636 0 0 0 0 0 0.811], [0 0.144 0 0 0 0 0 0 0.583 0 0 0 0 0 0 0 0 0 0.853 0 0 0 0 0], [0 0 0.115 0.79 0 0 0 0.628 0.784 0.0645 0.783 0.00649 0 0.244 0 0.151 0.928 0.741 0.188 0 0.855 0 0 0], [0.617 0.549 0 0 0 0 0 0.268 0.193 0.116 0 0 0 0 0 0 0.901 0 0 0 0 0 0 0], [0 0.807 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0398 0.814], [0 0.114 0 0 0 0 0 0.698 0 0 0 0 0 0 0 0 0 0 0 0.0662 0 0 0.721 0.277], [0.911 0.823 0 0 0 0 0 0.598 0 0 0 0 0 0 0 0 0 0 0 0.281 0.207 0 0.0694 0.622], [0.221 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.405 0], [0 0.448 0 0 0 0 0 0.605 0.334 0 0 0 0 0 0 0 0 0 0 0.979 0 0 0 0.689], [0 0.538 0 0.115 0.238 0 0 0.927 0.748 0.205 0 0.404 0 0.101 0 0.58 0 0 0.218 0.132 0.356 0 0.0234 0], [0.23 0.0832 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0], [0.719 0 0 0 0 0 0 0.721 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[7 7 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]"
  },
  {
    "category": "graphs",
    "algorithm": "floyd_warshall",
    "question": "floyd_warshall:\nA: [[0 0.202 0.368 0 0 0 0 0], [0.202 0 0 0.817 0 0.789 0 0], [0.368 0 0 0 0 0.072 0.256 0], [0 0.817 0 0.276 0 0 0 0], [0 0 0 0 0.422 0 0 0], [0 0.789 0.072 0 0 0.072 0 0], [0 0 0.256 0 0 0 0.569 0.706], [0 0 0 0 0 0 0.706 0]],",
    "example_output_A": "[7 7 7 7 7 7 7 7]]",
    "example_output_B": "[7 7 7 7 7 7 7 7]]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: floyd_warshall\nexample_output_A: [7 7 7 7 7 7 7 7]]\nexample_output_B: [4 4 4 4 4 4 4 4]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: GRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\nquestion: floyd_warshall:\nA: [[0 0.202 0.368 0 0 0 0 0], [0.202 0 0 0.817 0 0.789 0 0], [0.368 0 0 0 0 0.072 0.256 0], [0 0.817 0 0.276 0 0 0 0], [0 0 0 0 0.422 0 0 0], [0 0.789 0.072 0 0 0.072 0 0], [0 0 0.256 0 0 0 0.569 0.706], [0 0 0 0 0 0 0.706 0]],\nalgorithm_schema: Note: make compatible the general schema \nWorked example with answer tags \nInclude a blank schema without answer tags\nConvert all code into Markdown x Python\nGRAPH_ALGORITHM_SCHEMA = \"\"\"--- Graph Algorithm Schema ---\n\nInput:\n- algorithm: <algorithm_name>   # e.g., \"DFS\", \"BFS\", \"Dijkstra\"\n- graph:\n    type: \"adjacency_list\" | \"adjacency_matrix\"\n    value: [...]                 # adjacency structure\n- source_node: <s>              # only for single-source algorithms\n- example_output: [...]          # optional, for reference\n\nStep 1: Initialize variables\n- DFS / BFS:\n    pi = [NIL for each node]        # predecessor array\n    visited = [False for each node]\n- Dijkstra / Prim:\n    pi = [NIL for each node]        # predecessor array\n    dist = [\u221e for each node]        # distance array (Dijkstra)\n    key = [\u221e for each node]         # Prim's key array\n    visited = [False for each node]\n- Topological Sort:\n    visited = [False for each node]\n    topo_order = []\n- Articulation Points / Bridges / SCC:\n    discovery_time = [NIL for each node]\n    low = [NIL for each node]\n    pi = [NIL for each node]\n    visited = [False for each node]\n\nStep 2: Select traversal / algorithm\n- DFS: recursive or stack-based deep traversal\n- BFS: queue-based level traversal\n- Topological Sort: DFS with post-order appends\n- Articulation Points / Bridges: DFS with low values\n- SCC (Kosaraju): two-pass DFS (first for finishing times, second on transposed graph)\n- Dijkstra: min-heap, extract-min and relax neighbors\n- Prim: min-heap, extract-min key and update neighboring keys\n\nStep 3: Iterate through nodes / edges\n- DFS / BFS / Topological / SCC / AP/Bridges:\n    for each node u in graph:\n        if not visited[u]:\n            call dfs_visit(u)\n- Dijkstra / Prim:\n    while priority_queue not empty:\n        u = extract_min()\n        for each neighbor v of u:\n            relax(u, v)        # update dist or key and pi if necessary\n\nStep 4: Update final output\n- DFS / BFS: pi array (predecessor tree)\n- Topological Sort: topo_order array\n- Articulation Points / Bridges: list of nodes or edges\n- SCC (Kosaraju / Tarjan): component assignment per node\n- Dijkstra / Prim: pi array + dist/key array\n\nStep 5: Solve for final output\nOutput:\n{\n  \"pi\": [...],           # predecessor array, if applicable\n  \"dist\": [...],         # for weighted algorithms (Dijkstra)\n  \"key\": [...],          # for Prim's MST\n  \"topo_order\": [...],   # for topological sort\n  \"components\": [...]    # for SCC\n}\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBFS_EXAMPLE = \"\"\"Algorithm: BFS (Breadth-First Search)\nInput:\nalgorithm: \"BFS\"\ngraph:\n  type: \"adjacency_matrix\"\n  value:\n    [[0, 1, 0, 0, 1, 0],\n     [1, 0, 0, 1, 0, 0],\n     [0, 0, 0, 0, 0, 0],\n     [0, 1, 0, 1, 0, 0],\n     [1, 0, 0, 0, 1, 0],\n     [0, 0, 0, 0, 0, 1]]\nsource_node: 0\ninitial_trace: [0, 1, 2, 3, 4, 5]\n\n\nStep 1: Initialize variables\nvisited = [False, False, False, False, False, False]\npi = [None, None, None, None, None, None]\nqueue = []\n\n\nStep 2: Select traversal\nBFS \u2192 Queue-based level traversal.\n\nStep 3: Iterate through nodes / edges\nenqueue(0)\nvisited[0] = True\n\ndequeue(0) \u2192 visit neighbors [1, 4]\n    enqueue(1), enqueue(4)\n    pi[1] = 0, pi[4] = 0\n\ndequeue(1) \u2192 visit neighbors [3]\n    enqueue(3)\n    pi[3] = 1\n\ndequeue(4) \u2192 no new neighbors\ndequeue(3) \u2192 visit neighbors [1] \u2192 already visited\n\nenqueue remaining nodes not connected to visited (node 2 and 5) if using full initial_trace logic:\n    node 2 \u2192 disconnected, pi[2] = 2 (self)\n    node 5 \u2192 self-loop, pi[5] = 5\n\n\nStep 4: Update final output\npi = [0, 0, 2, 1, 0, 5]\n\n\nOutput:\n{\n  \"pi\": [0, 0, 2, 1, 0, 5]\n}\n\"\"\"\n\n\n <answer> [0, 0, 2, 1, 0, 5] <\\answer>\n\n\n\n\n\n\n\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[[0 0 0 1 0 2 2 6], [1 1 0 1 1 2 2 6], [2 0 2 1 2 2 2 6], [1 3 0 3 3 2 2 6], [4 4 4 4 4 4 4 4], [2 0 5 1 5 5 2 6], [2 0 6 1 6 2 2 6], [2 0 6 1 7 2 7 7]]"
  },
  {
    "category": "strings",
    "algorithm": "naive_string_matcher",
    "question": "naive_string_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1], key: [1 1 3 0 0 3 2 3 2 1 0 1 3 3 0 2 2 1 3 3 0 2 2 2 3 2 0 3 1 1 2 2 1 3 3 0 2], initial_trace: 0",
    "example_output_A": "15",
    "example_output_B": "15",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: naive_string_matcher\nexample_output_A: 15\nexample_output_B: 1\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: naive_string_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1], key: [1 1 3 0 0 3 2 3 2 1 0 1 3 3 0 2 2 1 3 3 0 2 2 2 3 2 0 3 1 1 2 2 1 3 3 0 2], initial_trace: 0\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "15"
  },
  {
    "category": "strings",
    "algorithm": "kmp_matcher",
    "question": "kmp_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1], key: [0 1 0 0 2 0 3 0 1 3 3 3 1 1 1 2 1 1 1 2 2 2 1 2 2 3 0 1 1 3 1 0 1 0 1 3 3 3 1 1 1], initial_trace: 0",
    "example_output_A": "3",
    "example_output_B": "3",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: kmp_matcher\nexample_output_A: 3\nexample_output_B: 0\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: kmp_matcher:\nstring: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1], key: [0 1 0 0 2 0 3 0 1 3 3 3 1 1 1 2 1 1 1 2 2 2 1 2 2 3 0 1 1 3 1 0 1 0 1 3 3 3 1 1 1], initial_trace: 0\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "7"
  },
  {
    "category": "geometry",
    "algorithm": "segments_intersect",
    "question": "segments_intersect:\nx: [0.212 0.845 0.981 0.521], y: [0.922 0.353 0.299 0.54]\nintersect:",
    "example_output_A": "1",
    "example_output_B": "1",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: segments_intersect\nexample_output_A: 1\nexample_output_B: 1\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: segments_intersect:\nx: [0.212 0.845 0.981 0.521], y: [0.922 0.353 0.299 0.54]\nintersect:\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "1"
  },
  {
    "category": "geometry",
    "algorithm": "graham_scan",
    "question": "graham_scan:\nx: [-0.127 -1.07 -0.763 -0.619 -0.352 -0.969 1.78 1.26 -0.619 -0.76 0.593 -1.17 0.273 0.334 1.26], y: [-0.412 -1.4 -0.051 -0.975 1.67 1.26 0.311 0.79 0.067 -0.787 0.755 1.49 -1.83 -1.87 -0.338],",
    "example_output_A": "[0 0 0 0 0 0 1 1 0 0 0 0 0 1 0]",
    "example_output_B": "[0 0 0 0 0 0 1 1 0 0 0 0 0 1 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: graham_scan\nexample_output_A: [0 0 0 0 0 0 1 1 0 0 0 0 0 1 0]\nexample_output_B: [0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: graham_scan:\nx: [-0.127 -1.07 -0.763 -0.619 -0.352 -0.969 1.78 1.26 -0.619 -0.76 0.593 -1.17 0.273 0.334 1.26], y: [-0.412 -1.4 -0.051 -0.975 1.67 1.26 0.311 0.79 0.067 -0.787 0.755 1.49 -1.83 -1.87 -0.338],\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[0 1 0 0 1 0 1 1 0 0 0 1 0 1 0]"
  },
  {
    "category": "geometry",
    "algorithm": "jarvis_march",
    "question": "jarvis_march:\nx: [0.478 -0.041 0.68 -0.984 0.993 -0.757 -1.4 -0.864 0.765], y: [-1.43 -1.26 0.483 -1.27 -1.27 -0.091 -0.505 -1.42 0.663],",
    "example_output_A": "[1 0 0 0 0 0 0 0 0]",
    "example_output_B": "[1 0 0 0 0 0 0 0 0]",
    "cot_prompt": "\nYou are a helpful math assistant adept at solving math problems. \nalgorithm_name: jarvis_march\nexample_output_A: [1 0 0 0 0 0 0 0 0]\nexample_output_B: [1 0 0 0 1 0 0 0 0]\n\n\n\nUse the following schema to work through your thought process\n\nworked_example: None\nquestion: jarvis_march:\nx: [0.478 -0.041 0.68 -0.984 0.993 -0.757 -1.4 -0.864 0.765], y: [-1.43 -1.26 0.483 -1.27 -1.27 -0.091 -0.505 -1.42 0.663],\nalgorithm_schema: None\n\n\nOn a new line at the end of your response. Output your answer with answer tags. DO NOT INCLUDE YOUR REASONING IN THE ANSWER TAGS\n\n<answer>[your answer here]<\u0007nswer>\n\n",
    "answer": "[1 0 0 1 1 1 1 1 1]"
  }
]